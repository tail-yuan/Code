### 死锁场景

当然可以！死锁是多线程编程中常见的问题，它发生在两个或多个线程彼此等待对方释放资源，导致程序无法继续执行的情况。以下是一些在C++开发中可能遇到的死锁问题的例子：

1. **资源竞争导致的死锁**：

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mutex1;
std::mutex mutex2;

void threadFunction1() {
    std::unique_lock<std::mutex> lock1(mutex1);
    std::this_thread::sleep_for(std::chrono::milliseconds(1)); // Introducing a small delay
    std::unique_lock<std::mutex> lock2(mutex2);
    std::cout << "Thread 1 is executing." << std::endl;
}

void threadFunction2() {
    std::unique_lock<std::mutex> lock2(mutex2);
    std::this_thread::sleep_for(std::chrono::milliseconds(1)); // Introducing a small delay
    std::unique_lock<std::mutex> lock1(mutex1);
    std::cout << "Thread 2 is executing." << std::endl;
}

int main() {
    std::thread t1(threadFunction1);
    std::thread t2(threadFunction2);

    t1.join();
    t2.join();

    return 0;
}
```

在上面的代码中，两个线程试图获取不同的互斥锁，但**由于获取锁的顺序不同，可能会导致死锁情况**。如果线程1获取了mutex1，而线程2获取了mutex2，然后它们互相等待对方释放另一个锁，就会发生死锁。

2. **递归锁可能导致的死锁**：

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;

void recursiveFunction(int depth) {
    std::unique_lock<std::mutex> lock(mtx);
    if (depth > 0) {
        std::cout << "Depth: " << depth << std::endl;
        recursiveFunction(depth - 1);
    }
}

int main() {
    std::thread t1([]() { recursiveFunction(5); });
    std::thread t2([]() { recursiveFunction(5); });

    t1.join();
    t2.join();

    return 0;
}
```

在这个例子中，两个线程都会递归地调用`recursiveFunction`，每次调用都会获取互斥锁。然而，如果两个线程**在递归调用的不同层级中阻塞**，它们可能会因为等待对方释放锁而进入死锁状态。

这些例子仅仅是展示了可能导致死锁的情况，实际上死锁问题可能更加复杂。避免死锁通常需要良好的设计和编程实践，例如按照固定的顺序获取锁，使用智能指针等。

### malloc calloc realloc

这三个函数，`malloc`、`calloc` 和 `realloc`，都涉及到内存分配和管理，但它们在细节和用途上有一些区别。以下是它们之间的主要区别：

1. **malloc**：
   - `malloc`（Memory Allocation）是C语言提供的函数，用于分配指定字节数的内存块。
   - `malloc` 函数的原型：`void* malloc(size_t size);`
   - 返回一个指向分配内存块的指针（`void*`类型），需要进行类型转换。
   - `malloc` 分配的内存内容是不初始化的，可能包含随机数据。

2. **calloc**：
   - `calloc`（Contiguous Allocation）也是C语言提供的函数，用于分配指定数量和大小的连续内存块，**并将其初始化为零。**
   - `calloc` 函数的原型：`void* calloc(size_t num_elements, size_t element_size);`
   - 返回一个指向分配内存块的指针（`void*`类型），需要进行类型转换。
   - `calloc` 分配的内存内容会被初始化为零，适用于需要清零初始化的场景，例如数组。

3. **realloc**：
   - `realloc`（Reallocate）也是C语言提供的函数，用于重新分配之前通过 `malloc` 或 `calloc` 分配的内存块的大小。
   - `realloc` 函数的原型：`void* realloc(void* ptr, size_t new_size);`
   - 第一个参数是之前分配的内存块的指针，第二个参数是新的大小。
   - `realloc` 可以用于扩展或缩小已分配内存块的大小，保留原有的数据内容。
   - 如果内存无法被扩展，`realloc` 可能会返回一个新的分配块，原来的指针会失效。

总结：
- `malloc` 和 `calloc` 主要用于分配内存，前者不进行初始化，后者进行零初始化。
- `realloc` 用于重新分配内存大小，可以用于扩展或缩小内存块，并保留原有数据。

在C++中，可以使用 `new` 和 `delete` 或者 C++11 引入的智能指针（`std::shared_ptr`、`std::unique_ptr`）来进行更安全和方便的内存管理。

### extern的作用

`extern` 是C和C++中的关键字，用于声明一个变量或函数的外部链接性，以便在其他文件中使用。它的作用如下：

1. **声明外部变量：** 当你在一个文件中使用了 `extern` 关键字来声明一个变量时，它表示该变量是在其他文件中定义的，你正在引用它。这样一来，编译器不会为该变量分配内存，而是假定该变量在其他地方已经定义了。这种机制用于在不同的源文件之间共享变量。

   示例：
   ```c
   // 文件 file1.c
   extern int globalVariable; // 声明外部变量 globalVariable

   // 文件 file2.c
   int globalVariable; // 定义外部变量 globalVariable
   ```

2. **声明外部函数：** 使用 `extern` 关键字来声明一个函数**表示该函数是在其他文件中定义的**，你在当前文件中使用它。这对于在一个文件中调用另一个文件中定义的函数是非常有用的。

   示例：
   ```c
   // 文件 file1.c
   extern void someFunction(); // 声明外部函数 someFunction

   // 文件 file2.c
   void someFunction() {
       // 函数定义
   }
   ```

3. **避免重复定义：** 如果你在多个源文件中包含同一个头文件，其中包含了某个变量或函数的声明，那么可以在其中一个文件中使用 `extern` 来避免重复定义。这样，编译器会认为**变量或函数在其他地方已经定义**。

   示例：
   ```c
   // 文件 file1.c
   int someVariable; // 定义 someVariable
   
   // 文件 file2.c
   extern int someVariable; // 声明外部变量 someVariable，避免重复定义
   ```

总之，`extern` 关键字用于声明在其他地方定义的变量或函数，以实现跨文件的数据共享和函数调用。

#### extern C

`extern "C"` 是用于 C++ 代码中的一个关键字组合，它的作用是**为了确保某一部分代码按照 C 语言的方式进行编译和链接**，以便与其他 C 代码或者使用 C 接口的代码进行正确的链接和交互。

在 C++ 中，由于函数重载、命名空间等特性，C++ 编译器会对函数名进行一些修饰（名字修饰或者名字矫正，Name Mangling），以便支持函数重载等功能。但这种名字修饰可能导致 C++ 代码与 C 代码之间的交互问题。

`extern "C"` 的作用是通知编译器将包含在其内部的代码按照 C 语言的规则来处理，不进行 C++ 特有的名字修饰。这样，可以确保在 C++ 代码中声明的函数、变量等在编译和链接时与 C 代码兼容。

举例来说，如果你在 C++ 中要编写一个函数，供 C 代码调用，你可以这样写：

```cpp
extern "C" {
    void c_function(int param) {
        // C++ code here
    }
}
```

在上面的代码中，`extern "C"` 将包裹的部分按照 C 语言规则来处理，使得 `c_function` 不会受到 C++ 名字修饰的影响，从而在 C 代码中可以直接通过 `c_function` 调用。

这在很多场景中很有用，比如在 C++ 中编写库供其他 C 代码调用，或者与一些底层操作系统的 C 接口进行交互。

### 函数调用时栈帧的变化

在函数调用的过程中，栈会发生变化以管理函数的执行环境和数据。除了局部变量，还有一些其他因素会引起栈的变化，这些因素包括：

1. **函数参数：** 当一个函数被调用时，函数的参数会被传递给函数。在栈上会为每个参数分配空间，以便函数可以访问这些参数的值。

2. **返回地址：** 在函数调用之前，调用方会将下一条要执行的指令的地址（返回地址）推入栈中。这是为了在函数执行完成后，能够返回到调用方继续执行。

3. **局部变量：** 函数内部声明的局部变量会在函数调用时在栈上分配内存，以便在函数内部使用。

4. **函数调用过程中的临时数据：** 在函数的执行过程中，可能需要临时保存一些数据，比如寄存器的值、临时计算结果等。这些数据也会被存储在栈上。

5. **栈帧：** 每个函数调用都会创建一个称为栈帧（stack frame）的数据块，用于存储函数的局部变量、参数、返回地址等信息。栈帧的创建和销毁导致栈的变化。

6. **调用其他函数：** 如果一个函数在其执行过程中调用了其他函数，它会在栈上为被调用函数创建一个新的栈帧，并将控制权传递给被调用函数。这会引起栈的进一步变化。

7. **递归调用：** 如果一个函数调用了自身，就会引起递归。每次递归调用都会创建一个新的栈帧，导致栈的持续变化。

总之，栈在函数调用过程中的变化主要涉及参数传递、返回地址、局部变量、栈帧的创建和销毁，以及在调用其他函数或递归调用时的变化。这种栈上的动态管理使得函数能够正确地执行并维护各个函数之间的数据隔离。

### sizeof

`sizeof(malloc(10))` 会执行成功，但它不会返回你可能期望的结果。

`sizeof` 是C和C++中的一个操作符，用于获取指定类型或表达式的字节大小。在这种情况下，`malloc(10)` 分配了一个大小为 10 字节的内存块，并返回指向该内存块的指针。然而，`sizeof(malloc(10))` 实际上只会返回指针的大小，而不是分配的内存块的大小。

通常情况下，指针的大小是固定的，取决于计算机的体系结构（如32位或64位系统）。在32位系统上，指针通常是4字节，而在64位系统上，指针通常是8字节。因此，`sizeof(malloc(10))` 在32位系统上可能返回4，而在64位系统上可能返回8。

如果你想获取分配的内存块的大小，你需要使用C标准库中的 `malloc` 函数之外的方法。例如，你可以通过 `malloc` 返回的指针来进行操作，并使用操作系统提供的功能来查询分配的内存块的大小。

### C++比C新增加的特性

C++是C语言的一个扩展，引入了许多新的特性和概念，以便更好地支持面向对象编程和其他编程范式。以下是C++相比于C语言增加的一些主要特性：

1. **类和对象：** C++引入了类和对象的概念，允许开发者使用面向对象的编程风格。类是一种用户自定义的数据类型，它可以封装数据和函数成员，使得数据和操作可以在一个单独的单元中组织起来。

2. **封装和访问控制：** C++允许在类中使用访问修饰符（public、private、protected）来控制成员的访问权限，从而实现了数据封装和隐藏。这样，可以将实现细节隐藏在类的内部，只暴露必要的接口给外部。

3. **继承：** C++支持继承机制，允许一个类从另一个类派生出来，并继承其属性和行为。这有助于代码的重用和层次结构的建立。

4. **多态：** C++引入了虚函数和运行时多态的概念。通过使用虚函数，可以在子类中重写父类的函数，实现运行时动态绑定，从而根据对象的实际类型调用相应的函数。

5. **函数重载：** C++允许在同一作用域内定义多个同名函数，只要它们的参数列表不同，从而实现了函数重载。

6. **运算符重载：** C++允许自定义类的运算符行为，通过重载运算符来定义类对象之间的操作。

7. **命名空间：** C++引入了命名空间的概念，可以帮助开发者避免命名冲突，将相关的代码组织到一个逻辑单元中。

8. **STL（标准模板库）：** C++引入了STL，提供了许多通用的数据结构（如向量、列表、映射等）和算法（如排序、搜索等），可以极大地简化编程任务。

9. **构造函数和析构函数：** C++引入了构造函数和析构函数的概念，用于对象的初始化和清理。构造函数在对象创建时自动调用，析构函数在对象销毁时自动调用。

10. **异常处理：** C++引入了异常处理机制，允许程序在出现异常情况时进行适当的处理，而不是直接崩溃。

11. **模板：** C++引入了模板，允许定义通用的函数和类，可以在编译时根据不同的类型生成不同的代码。

12. **类型转换：** C++引入了显式类型转换和隐式类型转换的概念，允许开发者在不同类型之间进行转换操作。

这些是C++相比C语言引入的一些主要特性。C++的设计目标是在保留C语言的能力的基础上，提供更多的编程工具和灵活性，以满足不同编程需求。

### 以太网模型

"以太网"通常指的是一种计算机网络技术，用于在局域网（LAN）中传输数据。它是最常见和广泛使用的局域网技术之一。以太网模型是描述这种网络技术的基本结构和运作方式。

以下是以太网的一般模型：

1. **物理层（Physical Layer）**：这是以太网模型的底层，定义了传输介质、电气特性、连接器类型等物理参数。最常见的以太网传输介质是双绞线，但也可以使用光纤等其他介质。物理层负责在传输介质上传输比特流。

2. **数据链路层（Data Link Layer）**：这一层负责将原始比特流组织成数据帧，并添加控制信息，如帧起始标识、地址信息、帧校验序列等。此外，数据链路层还处理物理层的错误，确保可靠的数据传输。以太网使用MAC（媒体访问控制）地址来唯一标识网络中的每个设备。

3. **网络层（Network Layer）**：在以太网中，通常使用的是TCP/IP协议族的网络层，它负责数据包的路由和转发。网络层将数据帧从一个设备传输到另一个设备，可能需要通过多个中间设备，如路由器。

4. **传输层（Transport Layer）**：传输层主要负责端到端的通信，通常处理数据的分段、重组和错误检测。在TCP/IP协议中，TCP（传输控制协议）是最常见的传输层协议，提供可靠的、面向连接的通信。

5. **应用层（Application Layer）**：最上层的应用层包含了各种网络应用和服务，如HTTP、FTP、SMTP等。这些协议和服务使应用程序能够通过网络进行通信和数据交换。

以太网的工作方式是通过**CSMA/CD**（载波监听多路访问/碰撞检测）协议来实现的。当多个设备尝试在同一时间发送数据时，它们会侦听传输媒介上是否有信号。如果检测到冲突（即多个设备同时发送信号），则会触发碰撞检测，并且发送设备会中止发送，等待随机时间后再次尝试。

随着时间的推移，以太网不断演化，传输速率提高，物理媒介改进，协议栈得以优化。从最初的10 Mbps（以太网）、100 Mbps（快速以太网）到1 Gbps（千兆以太网）甚至更高速率，以太网已经成为现代网络的基础。同时，还出现了无线局域网（Wi-Fi）等技术，扩展了局域网的范围和灵活性。

### delete[]如何得知释放多少内存

在 C++ 中，当你使用 `new` 运算符分配一个动态数组时，你通常需要使用 `delete[]` 运算符来释放相应的内存。这是因为 C++ 需要知道数组的大小以正确地释放内存。

在使用 `new` 运算符分配动态数组时，它会在分配的内存块的前几个字节中存储数组的大小。这样，当你使用 `delete[]` 运算符来释放内存时，C++ 可以通过读取存储的大小来确定需要释放的内存的数量。

以下是一个示例，说明了如何使用 `new` 和 `delete[]` 运算符来分配和释放动态数组：

```cpp
int main() {
    int size = 5;
    int* dynamicArray = new int[size]; // 分配动态数组

    // 初始化数组元素
    for (int i = 0; i < size; ++i) {
        dynamicArray[i] = i;
    }

    // 使用数组

    // 释放动态数组
    delete[] dynamicArray;

    return 0;
}
```

在这个示例中，我们使用 `new` 运算符分配了一个包含 5 个整数的动态数组。当我们使用 `delete[]` 运算符释放内存时，C++ 会根据存储的大小来释放正确数量的内存。

需要注意的是，使用 `delete` 运算符而不是 `delete[]` 运算符释放动态数组是错误的，因为它可能无法正确释放整个数组，从而导致内存泄漏。同样，使用 `delete[]` 运算符释放通过 `new` 运算符分配的单个对象也是不正确的。正确的释放与分配操作应该是匹配的。

### make_shared

当然了解！`std::make_shared` 是 C++ 标准库中的一个函数模板，用于创建共享指针（`std::shared_ptr`）的实例，并将指针指向一个动态分配的对象。它的使用有助于减少内存泄漏的风险，因为 `std::shared_ptr` 使用引用计数来跟踪对象的所有权，当所有引用都被释放时，对象会被自动删除。

以下是使用 `std::make_shared` 的基本语法：

```cpp
#include <memory>

int main() {
    // 创建一个共享指针，指向一个 int 对象
    std::shared_ptr<int> mySharedPtr = std::make_shared<int>(42);

    // 使用共享指针
    std::cout << *mySharedPtr << std::endl;

    return 0;
}
```

`std::make_shared` 函数模板接受一个可变数量的参数，这些参数将传递给对象的构造函数，以便在动态分配对象时进行初始化。通过使用 `std::make_shared`，你可以减少动态分配和引用计数所需的开销，**因为它会将引用计数的内存分配和对象的内存分配合并在一起。**

此外，使用 `std::make_shared` 可以更好地处理异常情况，因为它在分配内存和构造对象时是原子操作，可以避免在分配内存后抛出异常导致内存泄漏。

总而言之，`std::make_shared` 是 C++ 中一个非常有用的函数，有助于在动态分配对象时提供更好的内存管理和异常安全性。

### 为什么要进入TIME_WAIT状态

> 当最后一次发送ACK时，数据并不会再3增多。尽量保证历史发送的网络数据在网络中消散，避免有的数据没有被双方收取。2倍至少保证了一来一回的时间，最多残留的数据就是2MSL。因为是数据断开阶段不会再进行数据的更新了。
>
> 无法保证发送的ACK对方收到了，如果我还收到了对面发来的FIN，就说明我发的ACK丢了，如果我没再次收到FIN，我就认为他收到ACK了**，没有消息就是好消息**。
>
> 所以就是尽量保证最后一个ACK被对方收到了

**首先，这样做是为了确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。**

TCP 在设计的时候，做了充分的容错性设计，比如，TCP 假设报文会出错，需要重传。在这里，如果图中主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文。如果主机 1 没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误。现在主机 1 知道自己处于 TIME_WAIT 的状态，就可以在接收到 FIN 报文之后，重新发出一个 ACK 报文，使得主机 2 可以进入正常的 CLOSED 状态。

**第二个理由和连接“化身”、报文迷走有关系，为了让旧连接的重复分节在网络中自然消失。**

我们知道，在网络中，经常会发生报文经过一段时间才能到达目的地的情况，产生的原因是多种多样的，如路由器重启，链路突然出现故障等。如果迷走报文到达时，发现 **TCP 连接四元组（源 IP，源端口，目的 IP，目的端口）**所代表的连接不复存在，那么很简单，这个报文自然丢弃。



我们考虑这样一个场景，在原连接中断后，又重新创建了一个原连接的“化身”，说是化身其实是因为这个连接和原先的连接四元组完全相同，如果迷失报文经过一段时间也到达，那么这个报文会被误认为是连接“化身”的一个 **TCP 分节**，这样就会对 TCP 通信产生影响。

![img](https:////upload-images.jianshu.io/upload_images/12979420-0a0bf334e80ec0eb.png?imageMogr2/auto-orient/strip|imageView2/2/w/660/format/webp)

所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以让两个方向上的分组都被丢弃，使得原来连接的分组在网络中都自然消失，再出现的分组一定都是新化身所产生的。



**注意，2MSL 的时间是从主机 1 接收到 FIN 后发送 ACK 开始计时的；**

如果在 TIME_WAIT 时间内，因为主机 1 的 ACK 没有传输到主机 2，主机 1 又接收到了主机 2 重发的 FIN 报文，那么 2MSL 时间将重新计时。

道理很简单，因为 2MSL 的时间，目的是为了让旧连接的所有报文都能自然消亡，现在主机 1 重新发送了 ACK 报文，自然需要重新计时，以便防止这个 ACK 报文对新可能的连接化身造成干扰。

**TIME_WAIT是一个抽象的定义，而TCP_TIMEWAIT_LEN是Linux默认的值，是一个常量。**

### 纯虚函数 vs 普通函数

纯虚函数（Pure Virtual Function）和普通函数是C++中的两种不同的函数类型，它们在语法和用途上有很大的区别。

**1. 纯虚函数：**
纯虚函数是一种在基类中声明但没有实际实现的虚函数。它通过在函数声明的结尾加上`= 0`来表示。纯虚函数用于定义一个接口，**强制派生类去实现该函数**。派生类必须提供对纯虚函数的实际实现，否则派生类也将成为抽象类，无法实例化。

例如：
```cpp
class Base {
public:
    virtual void doSomething() = 0; // 纯虚函数
};

class Derived : public Base {
public:
    void doSomething() override {
        // 实现具体的操作
    }
};
```

**2. 普通函数：**
普通函数是一种有实际实现的函数，可以直接被调用。它可以在类内部或类外部定义，根据需求进行调用。普通函数不需要使用`virtual`关键字进行声明，也不需要`= 0`来表示纯虚函数。

例如：
```cpp
class MyClass {
public:
    void regularFunction() {
        // 函数实现
    }
};

int main() {
    MyClass obj;
    obj.regularFunction(); // 调用普通函数
    return 0;
}
```

**区别总结：**
- 纯虚函数没有实际的函数实现，必须在派生类中实现才能创建对象。
- 普通函数有实际的函数实现，可以在基类和派生类中直接使用。
- 纯虚函数用于定义接口，强制派生类实现特定的方法。
- 普通函数用于封装功能逻辑，可以直接调用。

总之，纯虚函数和普通函数在面向对象编程中具有不同的角色和用途，通过它们可以实现多态性和代码重用。

### map对比unordered_map

`std::map`和`std::unordered_map`是C++标准库中的两种关联容器，用于实现键-值对的存储和查找。它们在底层实现和性能特点上有所不同。

**1. std::map：**
`std::map`是基于红黑树（一种自平衡二叉搜索树）实现的关联容器。它的特点包括：

- 键值对是按照键的大小顺序存储的，因此在使用自定义类型作为键时，需要定义比较函数或使用重载的比较操作符来确定键的顺序。
- 插入、查找、删除操作的平均时间复杂度为 O(log n)，因为树的高度保持平衡。
- 存储的键值对是有序的，可以方便地进行区间遍历和查找。
- 适用于对键有序要求较高的场景，例如需要按照键的顺序进行遍历和查找的情况。

以下是使用`std::map`的示例：
```cpp
#include <map>

int main() {
    std::map<int, std::string> myMap;
    myMap[1] = "one";
    myMap[2] = "two";
    // ...

    // 查找键为2的值
    std::string value = myMap[2];

    return 0;
}
```

**2. std::unordered_map：**
`std::unordered_map`是基于哈希表实现的关联容器。它的特点包括：

- 键值对的存储是无序的，每个键通过哈希函数计算出一个索引，因此查找速度很快，平均情况下为 O(1)。
- 插入、查找、删除操作的平均时间复杂度为 O(1)，但是在极端情况下可能会达到 O(n)，例如哈希冲突较多时。
- 对于自定义类型作为键，需要提供哈希函数和相等比较函数。
- 适用于需要高效查找，对键的顺序没有要求的场景。

以下是使用`std::unordered_map`的示例：
```cpp
#include <unordered_map>

int main() {
    std::unordered_map<int, std::string> myMap;
    myMap[1] = "one";
    myMap[2] = "two";
    // ...

    // 查找键为2的值
    std::string value = myMap[2];

    return 0;
}
```

总的来说，如果你对键的有序性没有特别要求，且需要高效的查找操作，可以考虑使用`std::unordered_map`。如果需要有序存储，并且对性能要求相对较低，可以使用`std::map`。选择哪种关联容器取决于具体的应用需求。

### 常量指针vs指针常量

在C++中，常量指针和指针常量是两种不同的指针类型，它们的定义和含义有所不同。

**1. 常量指针：**
常量指针是指向常量的指针，意味着指针所指向的值不能通过该指针进行修改。但是指针本身是可以改变指向的，也就是说可以将指针指向不同的地址。

定义一个常量指针的方式如下：
```cpp
const int* ptr; // 声明一个指向常量int的指针
```
或者
```cpp
int const* ptr; // 同样是声明一个指向常量int的指针
```

这两种写法都是等效的，它们声明了一个指向常量int的指针，意味着通过这个指针不能修改所指向的int的值。

**2. 指针常量：**
指针常量是一个指针，其值（即地址）是不可改变的，但是可以通过该指针来修改所指向的值。

定义一个指针常量的方式如下：
```cpp
int* const ptr; // 声明一个指针常量，指向int
```

这里，`ptr`是一个指向int的指针常量，意味着一旦初始化后，它的值（即所指向的地址）就不能再改变，但是你可以通过这个指针来修改所指向的int的值。

需要注意的是，在定义指针常量时必须进行初始化，因为之后不能再改变它的值。

综上所述，常量指针和指针常量有着不同的语义和用途，要根据具体的需求来选择使用哪种类型的指针。