### 程序启动的过程

1. 首先程序文件加载到内存中,操作系统为了管理进程要创建PCB,文件描述符表,为每一个进程创建私有的进程地址空间.然后操作系统的加载器负责把可执行文件的**数据段和代码段**映射到进程的虚拟内存空间中。
   * 注: PCB中包含关于进程的描述信息,进程优先级,应对信号处理,IO设备交互信息,上下文数据保存等.

2. 加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的**动态链接库**。

3. 加载器针对该程序的每一个动态链接库调用LoadLibrary.

（1）查找对应的动态库文件，加载器为该动态链接库*确定一个合适的基地址*。

（2）比较应用程序要求的导入符号*是否匹配该库的导出符号*。

（3）针对该库的导入符号表，*查找对应的依赖的动态链接库*，如有跳转，则跳到

（4）调*用该动态链接库的初始化函数*.

4. 初始化应用程序的全局变量，对于全局对象自动调用构造函数。

5. 进入应用程序入口点函数开始执行。

#### 程序地址空间

![image-20230911164113222](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230911164113222.png)

> 如上图，**从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等**组成。
>
> 1. **数据段：**存放程序中已初始化的全局变量和静态变量的一块内存区域。
>
> 2. **代码段：**存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。
>
> 3. **BSS** 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。
>    * BSS段通常是指用来存放程序中**未初始化的或者初始化为0的全局变量**和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。
>
> 4. 可执行程序在运行时又会多出两个区域：堆区和栈区。
>
> **堆区：**动态申请内存用。堆从低地址向高地址增长。
>
> **栈区：**存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。
>
> 5. 最后还有一个**共享区**，位于堆和栈之间。

### 内存对齐规则

1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offffset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。

2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。

3. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。

4. sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。

