#### 进程状态转换 vs 进程调度

进程状态转换是进程管理的一个方面，与进程调度相关，但它们不是完全相同的概念。

进程状态转换指的是一个进程在其生命周期内可能经历的不同状态之间的切换。在典型的多任务操作系统中，进程可以处于以下几种状态：

1. 就绪态（Ready）：进程已经准备好执行，但尚未获得 CPU 时间片，等待进程调度器分配 CPU 时间。

2. 运行态（Running）：进程正在执行，占用 CPU 时间片。

3. 阻塞态（Blocked）：进程因等待某些事件（如输入/输出完成、信号等）而被阻塞，暂时无法执行。一旦事件发生，进程将从阻塞态切换到就绪态，等待进程调度器分配 CPU 时间。

4. 终止态（Terminated）：进程已经执行完毕或被强制终止，等待操作系统清理其资源。

进程状态的转换通常是由**操作系统内核管理**的，根据不同的事件和条件来决定将进程从一个状态切换到另一个状态。这个过程涉及进程的创建、调度、等待资源、释放资源等操作。

进程调度是进程状态转换的一部分，它是指**操作系统内核根据一定的调度算法从就绪态的进程中选择一个进程分配 CPU 时间片，使其处于运行态**。调度算法的目标是公平地分配 CPU 时间，以确保多个进程都有机会执行。

因此，进程状态转换和进程调度都是操作系统的关键组成部分，用于管理和控制多个进程的执行，以实现多任务处理。状态转换决定了进程在哪些状态之间切换，而调度决定了在就绪态的进程中选择哪一个执行。

### 进程状态转换

在操作系统中，一个进程可以经历多种状态，例如就绪、运行、阻塞等。这些状态之间的转换是通过不同的事件和操作触发的。以下是常见的进程状态之间的转换过程：

1. **创建（New）**：进程被创建，分配必要的资源，如内存空间、标识符等。

2. **就绪（Ready）**：进程已被创建，但还未开始执行。它已经具备运行所需的全部资源，只需等待CPU时间。

3. **运行（Running）**：进程正在CPU上执行。只有一个进程可以处于运行状态。当CPU时间片用完或进程主动让出CPU时，它会从运行状态切换到就绪状态。

4. **阻塞（Blocked）**：也称为等待（Waiting），进程因为某些事件（如I/O操作）而暂时无法继续执行。在等待事件完成之前，进程会从运行状态切换到阻塞状态。

5. **终止（Terminated）**：进程执行完成，释放占用的资源，包括内存和文件描述符等。

基于这些状态，以下是状态之间的主要转换过程：

- **创建 -> 就绪**：进程被创建并初始化，准备好运行，但还没有得到CPU的执行时间。

- **就绪 -> 运行**：当调度器选择一个就绪进程，并分配给它CPU时间时，进程从就绪状态切换到运行状态。

- **运行 -> 就绪**：进程在运行时，如果时间片用完、被更高优先级的进程抢占、或者主动释放CPU，它会从运行状态切换到就绪状态。

- **运行 -> 阻塞**：当进程发起阻塞操作，例如等待I/O完成，它会从运行状态切换到阻塞状态。

- **阻塞 -> 就绪**：当阻塞的事件完成，例如I/O操作完成，进程从阻塞状态切换到就绪状态。

- **运行 -> 终止**：当进程完成其任务，它会从运行状态切换到终止状态。

注意，进程状态之间的转换可能因操作系统和硬件的不同而有所差异。调度算法、中断、系统调用和外部事件都可以影响进程状态的转换。

![image-20230830125225710](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230830125225710.png)

### 进程线程调度算法

在操作系统中，进程和线程的调度算法用于决定哪个进程或线程在给定的时间片内获得CPU时间以执行。以下是一些常见的进程和线程调度算法：

#### **进程调度算法：**

1. **先来先服务 (FCFS, First-Come, First-Served)**：按照到达时间的顺序为进程分配CPU时间，直到进程完成或被阻塞。可能导致长作业等待时间过长，产生“饥饿”现象。

2. **最短作业优先 (SJF, Shortest Job First)**：选择估计运行时间最短的进程优先执行。可以最小化平均等待时间，但需要准确的作业时间估计。

3. **最短剩余时间优先 (SRTF, Shortest Remaining Time First)**：在最短作业优先的基础上，允许已运行进程被更短进程抢占。

4. **优先级调度**：为每个进程分配一个优先级，并按优先级高低执行。可能导致低优先级进程“饥饿”，需要合理的优先级调整机制。

5. **轮转调度 (Round Robin)**：每个进程在一个时间片内执行，然后切换到下一个进程。适合分时系统，但可能导致高响应时间和上下文切换开销。

6. **多级队列调度**：将进程划分为**多个优先级队列**，每个队列使用**不同的调度算法**，例如高优先级队列使用SJF，低优先级队列使用轮转调度。

7. **多级反馈队列调度**：类似多级队列，但允许进程在不同队列之间移动，根据执行时间调整优先级。

#### **线程调度算法：**

线程调度算法通常是基于进程调度算法，但有时会更加轻量级，因为线程在同一进程内共享地址空间。

1. **抢占式调度**：线程可以被其他线程抢占，常见于**多核系统**中，提高资源利用率。

2. **协作式调度**：线程只在**主动放弃CPU时**才会切换，通常需要线程之间的合作。

3. **多队列调度**：根据线程的优先级、执行状态等将线程**划分为多个队列**，**每个队列使用不同的调度策略。**

4. **分时调度**：在多个线程之间分配时间片，类似于轮转调度。

5. **按需调度**：只有当需要时才会创建和调度线程，适用于**按事件驱动的应用。**

不同的调度算法适用于不同的场景和需求。选择合适的调度算法可以最大程度地提高系统的性能、响应时间和资源利用率。