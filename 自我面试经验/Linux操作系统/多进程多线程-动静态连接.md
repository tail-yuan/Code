### 多进程和多线程的区别

多线程和多进程有许多区别，它们是并发编程的两种不同方式，具有不同的特点和适用场景。以下是一些主要的区别：

1. **资源占用和开销**：
   - **多进程**：每个进程都有*独立的内存空间和系统资源*，因此进程之间的资源隔离较好，但也导致了较大的内存开销和系统资源占用。
   - **多线程**：线程共享同一进程的内存空间和系统资源，因此线程之间的资源共享更容易，但也需要较少的内存和系统资源。

2. **通信和同步**：
   - **多进程**：进程之间通常需要使用进程间通信（Inter-Process Communication，IPC）机制来进行数据传输和同步，例如*管道、套接字、共享内存*等。
   - **多线程**：线程之间可以直接共享内存，因此通信和同步更为简便，但也需要注意线程安全问题，以避免竞态条件和死锁等问题。

3. **创建和销毁开销**：
   - **多进程**：创建和销毁进程通常比较耗时，因为每个进程都需要分配独立的内存空间和系统资源。
   - **多线程**：创建和销毁线程通常比较轻量级，因为线程共享父进程的资源。

4. **并发性和性能**：
   - **多进程**：由于进程之间的独立性，多进程可以更好地利用多核处理器，适用于**计算密集型任务**。
   - **多线程**：多线程适用于**I/O密集型任务**，**因为线程之间的切换开销相对较小**，但在多核处理器上可能无法充分利用多核的优势。

5. **稳定性**：
   - **多进程**：由于进程之间的隔离性，一个进程的崩溃通常不会影响其他进程。
   - **多线程**：一个线程的崩溃可能会导致整个进程崩溃，因为它们共享相同的地址空间。

6. **编程复杂性**：
   - **多进程**：通常更容易编写稳定的多进程应用程序，因为进程之间的数据隔离较好。
   - **多线程**：线程之间的共享状态可能导致更复杂的编程，需要更多的注意力来避免竞态条件和死锁等问题。

选择多线程或多进程取决于具体的应用需求和性能要求。通常，多线程更适用于I/O密集型任务，而多进程更适用于计算密集型任务。此外，有些应用可能会同时使用多线程和多进程，以充分利用它们的优势。

#### 应用场景

多进程和多线程在应用场景中有不同的优势和适用性，以下是它们各自常见的应用场景：

**多进程的应用场景：**

1. **计算密集型任务**：多进程适用于需要大量CPU计算资源的任务，例如科学计算、模拟、图像渲染等。

2. **服务器应用程序**：多进程可**用于构建高性能服务器，**每个客户端连接可以由一个独立的进程处理，提高并发性能和可伸缩性。(负载均衡式OJ系统采用fork创建多进程的原因)

3. **分布式系统**：多进程可用于构建分布式系统，每个进程可以在不同的计算机上运行，协同处理分布式任务。

4. **安全性要求高的应用**：多进程提供了*更好的隔离*，可用于构建安全性要求高的应用程序，一个进程的崩溃不会影响其他进程。

5. **并行计算**：多进程可用于将大型计算问题分解成多个子任务，每个子任务由一个独立的进程处理，从而加速计算过程。

**多线程的应用场景：**

1. **I/O密集型任务**：多线程适用于需要频繁进行I/O操作（如文件读写、网络通信）的任务，因为线程之间的切换开销较小。

2. **图形用户界面(GUI)应用程序**：多线程可用于保持UI响应，以便在主线程处理用户界面事件的同时，后台线程可以执行其他任务。

3. **Web服务器**：多线程可用于处理多个客户端的HTTP请求，因为I/O操作是主要的工作负载。

4. **多媒体处理**：多线程适用于图像处理、音频处理、视频编解码等多媒体任务，以充分利用多核处理器。

5. **并发数据结构**：多线程可用于实现并发数据结构，如线程安全的队列、哈希表等。

6. **线程池**：线程池是一种常见的多线程模型，用于管理和复用线程来执行任务队列中的工作。

7. **并行编程**：多线程可用于并行化程序，以提高程序的性能，例如并行编程框架如OpenMP。

### 动态链接vs静态链接

动态链接和静态链接是两种不同的方式**将程序的不同部分（通常是函数和库）组合在一起**，以创建可执行文件。它们有以下主要区别：

1. 静态链接（Static Linking）：
   - 静态链接发生在**编译阶段**。
   - 在静态链接中，编译器将所有程序的不同部分（函数、库等）合并成一个单独的可执行文件。
   - 执行文件包含所有需要的代码和数据，因此它是独立的，**不需要依赖外部库**。
   - 可执行文件的大小相对较大，因为它包含了所有依赖项的副本。
   - 静态链接适用于创建独立的、可分发的二进制文件，但可能会导致代码冗余，因为每个可执行文件都包含了相同的库的副本。

2. 动态链接（Dynamic Linking）：
   - 动态链接发生**在运行时**。
   - 在动态链接中，编译器生成的可执行文件只包含程序的部分代码和链接信息，而不包括所有依赖的库的代码。
   - **当程序运行时**，操作系统的动态链接器（例如，在Windows上是DLL，Linux上是SO）负责加载和链接所需的库文件，以供程序使用。
   - 动态链接可以节省磁盘空间，因为多个程序可以共享相同的库。
   - 如果库被更新或修复，只需更新库文件，而不需要重新编译所有使用它的程序。
   - 动态链接使得程序更加模块化，并且可以减少内存占用，因为多个程序可以共享相同的库的副本。

总结来说，静态链接将所有代码和库合并成一个单独的可执行文件，而动态链接将程序的一部分与库文件分开，**实际的链接发生在运行时**。每种链接方式都有其优点和缺点，选择取决于项目的需求和设计目标。静态链接适用于独立分发的可执行文件，而动态链接通常更灵活，可以共享库和更容易维护。

### 模板声明和定义都放在.h文件中

这是由C++编译器的性质决定的。C++采用了分离式编译的方法，.h头文件仅仅是在预处理阶段进行展开的，真正进行的是对.cpp文件的编译。编译器在编译时，看到模板并不会进行任何操作，而是在模板实际使用时（实例化），才会进行代码生成。

如果模板定义放在.h头文件中，模板实现放在.cpp文件中，编译时可以看到模板的声明，但找不到定义，因此会成为外部符号，而在链接时，必然无法找到模板的实现（该外部符号的对应符号），导致链接失败。而如果模板定义在.h头文件中，则可以在编译时就找到模板的定义，进行代码生成。

如果你将模板类的声明放在头文件中，而将实现放在.cpp文件中，可能会导致链接错误或编译错误，因为编译器需要访问模板类的实现来生成相应的代码。

1. 链接错误：当你在源文件中**实例化模板类**时，编译器需要访问模板类的定义，以便生成相应的代码。如果模板类的定义在.cpp文件中，编译器无法找到它，因此会导致链接错误。
2. 编译错误：某些编译器要求将模板类的定义放在同一个文件中，以确保**正确的实例化和代码生成**。将模板类的实现放在.cpp文件中可能会导致编译错误。

### 并行和并发的区别

并发: 2个或者多个任务在同一时间段内发生,但是只有一个CPU.微观上仍然是串行,CPU将执行时间划分为多个时间段,每个线程都被分配时间片,在一段时间内,其他进程都挂起等待状态,只不过是时间片很短并且线程切换速度很快,导致宏观上看来是并发.

并行: 2个以上线程同时发生,1个以上的CPU,是真正的多个线程同时执行,互相并不抢占CPU资源.

### 线程同步的方式

因为线程之间内容是共享的,实质就是让多个线程按照一定的次序进行获取共享的内存资源.

##### 互斥锁

当一个线程获取锁之后,其他线程进行阻塞状态.

##### 自旋锁

当一个线程获取到锁获取资源时,其他线程处于忙等待状态,仍然占据CPU资源.

##### 读写锁

读线程共享读锁.写线程独占写锁,处于互斥状态.

##### 条件变量

进入临界区之后,先要获取锁,不满足某个条件时,会释放锁进入阻塞等待,当条件就绪时又会重新获取到锁.通常是和互斥锁一起使用.

##### 屏障

协调多个线程并行工作的同步机制,直到所有的线程都到达某一个点时,在集体进行下一步操作.

##### 信号量

信号量是描述可用资源个数的计数器机制.P操作申请信号量,信号量--;V操作释放信号量,信号量++.

### 每日Linux指令

#### uniq

在输出方面实现去重,将连续重复的行去重.

```perl6
[root@yuanwei ~]# cat test4.txt
hello
hello
hello 
Hello
hello world
hi world
[root@yuanwei ~]# uniq test4.txt
hello
hello #这里有一个空格,也是不同内容的行.
Hello
hello world
hi world
[root@yuanwei ~]# vim test4.txt 
[root@yuanwei ~]# uniq test4.txt
hello
Hello
hello world
hi world
#将结果输出到test5.txt文件中
[root@yuanwei ~]# uniq test4.txt test5.txt
[root@yuanwei ~]# cat test5.txt
hello
Hello
hello world
hi world
#参数
#-c; 将出现次数都打印出来
[root@yuanwei ~]# uniq -c  test4.txt
      3 hello
      1 Hello
      1 hello world
      1 hi world

#-d: 只将重复出现的行打印出来
[root@yuanwei ~]# uniq -d test4.txt
hello
#-u: 打印不重复出现的行
[root@yuanwei ~]# uniq -u test4.txt
Hello
hello world
hi world
#-i: 不区分大小写,将内容看做是重复内容
[root@yuanwei ~]# uniq -i test4.txt
hello
hello world
hi world
#-f:跳过第一个字段
[root@yuanwei ~]# uniq -f 1 test4.txt
hello
hello world
```

#### sort

指定文件内容或者标准输入内容进行排序

```perl6
[root@yuanwei ~]# cat test4.txt | sort -r
hi world
hello world
Hello
hello
hello
hello
#指定第几列进行排序
[root@yuanwei ~]# sort test4.txt -k 3
hello
hello
hello
Hello
hello world
hi world
#指定分隔符进行排序
[root@yuanwei ~]# sort test4.txt -t "e"
hello
hello
hello
Hello
hello world
hi world

[root@yuanwei test2]# ll
total 12
-rw-r--r-- 1 root root   67 Feb 26  2023 env.c
-rw-r--r-- 1 root root   32 Apr 27 17:54 test1.c
-rw-r--r-- 1 root root 1023 Apr 27 10:02 test.c
-rw-r--r-- 1 root root    0 Sep  5 13:18 test.txt
# 指定第5列字段将文件夹内容排序
[root@yuanwei test2]# ls -l | sort -k 5
total 12
-rw-r--r-- 1 root root    0 Sep  5 13:18 test.txt
-rw-r--r-- 1 root root 1023 Apr 27 10:02 test.c
-rw-r--r-- 1 root root   32 Apr 27 17:54 test1.c
-rw-r--r-- 1 root root   67 Feb 26  2023 env.c
# 考虑单位进行排序
[root@yuanwei test2]# ls -l | sort -k  5 -h
-rw-r--r-- 1 root root    0 Sep  5 13:18 test.txt
total 12
-rw-r--r-- 1 root root   32 Apr 27 17:54 test1.c
-rw-r--r-- 1 root root   67 Feb 26  2023 env.c
-rw-r--r-- 1 root root 1023 Apr 27 10:02 test.c
# -o 将文件内容输出
[root@yuanwei test2]# ls -l | sort -k  5 -h -o test1.txt
[root@yuanwei test2]# cat test1.txt
-rw-r--r-- 1 root root    0 Sep  5 13:18 test.txt
-rw-r--r-- 1 root root    0 Sep  5 13:22 test1.txt
total 12
-rw-r--r-- 1 root root   32 Apr 27 17:54 test1.c
-rw-r--r-- 1 root root   67 Feb 26  2023 env.c
-rw-r--r-- 1 root root 1023 Apr 27 10:02 test.c
# 排序文件.默认空行在前
[root@yuanwei ~]# sort test4.txt
hello
hello
hello
Hello
hello world
hi world
# 实现去重
[root@yuanwei ~]# sort test4.txt -u
hello
Hello
hello world
hi world
# 检查是否已经被排序,打印未被排序的行
[root@yuanwei ~]# sort test4.txt -u | sort -c
[root@yuanwei ~]# 

```

