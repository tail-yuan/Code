### [网络丢包](https://www.xiaolincoding.com/network/3_tcp/tcp_drop.html#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%97%B6%E4%B8%A2%E5%8C%85)

#### 产生丢包现象的场景

##### 1. 建立连接时丢包

当三次握手时半连接队列满时,新来的连接就会被舍弃.

##### 2. 流量控制丢包

应用层能发网络数据包的软件有那么多，如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消，那怎么办？让数据按一定的规则排个队依次处理，也就是所谓的**qdisc**(**Q**ueueing **Disc**iplines，排队规则)，这也是我们常说的**流量控制**机制。排队，得先有个队列，而队列有个长度: **流控队列**的长度。

当发送数据过快，流控队列长度`txqueuelen`又不够大时，就容易出现**丢包**现象。

当遇到这种情况时，我们可以尝试修改下流控队列的长度。比如像下面这样将eth0网卡的流控队列长度从1000提升为1500.

##### 4. RingBuffer过小

发来的数据会优先存放在Ringbuffer就是接收缓冲区中,等待内核触发中断慢慢收走.

接收缓冲区如果过小而此时的发送数据又过快的话就有可能发生溢出,此时也会产生丢包.

##### 5. 网卡性能

网卡作为硬件，**传输速度是有上限的**。当网络传输速度过大，达到网卡上限时，就会发生丢包.

网卡和它的驱动导致丢包的场景也比较常见，原因很多，比如**网线质量差，接触不良**

##### 6. 网络丢包

前面提到的是两端机器内部的网络丢包，除此之外，两端之间那么长的一条链路都属于外部网络，这中间有各种路由器和交换机还有光缆啥的，丢包也是很经常发生的。这些丢包行为发生在中间链路的某些个机器上，我们当然是没权限去登录这些机器。但我们可以通过一些命令观察整个链路的连通情况。

- 当你发现服务异常的时候，比如接口延时很高，总是失败的时候，可以用ping或者mtr命令看下是不是中间链路发生了丢包。

#### 用了TCP一定不会丢包吗?

TCP保证的可靠性，是**传输层的可靠性**。也就是说，**TCP只保证数据从A机器的传输层可靠地发到B机器的传输层。**

至于数据到了接收端的传输层之后，能不能保证到应用层，TCP并不管。

假设现在，我们输入一条消息，从聊天框发出，走到**传输层TCP协议的发送缓冲区**，不管中间有没有丢包，最后通过重传都保证发到了对方的**传输层TCP接收缓冲区**，此时接收端回复了一个`ack`，发送端收到这个`ack`后就会将自己**发送缓冲区**里的消息给扔掉。到这里TCP的任务就结束了。

TCP任务是结束了，但聊天软件的任务没结束。

**聊天软件还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。**

发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。

于是乎，**消息就丢了。**

#### TCP解决不了的丢包怎么解决?

例子: 聊天软件三端通信

对于**发送方**，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。

如果**接收方**的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。

可以看出，**TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。**



### coreDump

##### 什么是coredump

应用程序运行出错或异常退出时，在满足一定条件下产生一个core文件，例如程序收到SIGABRT、SIGEMT等信号时(注：在signal.h里说明了哪些新号会产生coredump)都会出现coredump，我们平时见到最多的应该就是段错误。
core文件包含了程序运行时内存、寄存器状态、堆栈指针、内存管理信息以及函数调用堆栈信息。
我们通过分析core文件可以找到应用程序崩溃的地方

##### coredump产生的条件

（1）coredump产生主要原因：

1、内存访问越界
2、多线程程序使用了线程不安全的函数。
3、多线程读写的数据未加锁保护。
4、非法指针
5、堆栈溢出

##### 如何生成coredump

1. 首先需要内核支持kernel选项
2. 设置ulimit -c unlimited

可以通过ulimit -a查看core文件大小限制，core文件大小不能太小，否则不能生成core文件
3. 默认core文件生成在当前目录，可以通过下面命令修改生成位置

```perl6
可以通过/proc/sys/kernel/core_pattern进行设置。

%p  出Core进程的PID
%u  出Core进程的UID
%s  造成Core的signal号
%t  出Core的时间，从1970-01-0100:00:00开始的秒数
%e  出Core进程对应的可执行文件名
eg:
    echo "core-%e-%p-%s-%t" > /proc/sys/kernel/core_pattern。

```

在每个进程下都有coredump_filter节点/proc/pid/coredump_filter。

通过配置coredump_filter可以选择需在coredump的时候，将哪些内容[dump](https://so.csdn.net/so/search?q=dump&spm=1001.2101.3001.7020)到core文件中。

### 数组指针

```C++
#include<iostream>
using namespace std;

int main()
{
	int matrix[3][2] = {1,2,3,4,5,6};
	int(*p)[2] = matrix;//p {1,2}
	++p;	//{3,4}
	printf("%d\n",*p[1]);//5
	//**(p+1) 5
	//p[1] == *(p+1) {5,6} 优先级[] > *
	printf("%d\n", (*p)[1]);//4
	return 0;
}
```

### 常用网络协议

`SMTP协议`: 邮件传输协议

`HTTP`:万维网协议

`TELNET`: 远程登录协议

`DHCP`: 动态分配IP地址

`DNS`:域名解析协议

`SSH`: 更加安全的远程登录协议

`SSL/TLS`:对http进行加密的协议

`FTP`: 文件传输协议

`ARP`: 地址解析协议,将IP地址转化为MAC地址,在局域网通信中.

##### OSI七层模型

> * 应用层:为应用程序提供服务并规定**应用程序中通信相关的细节**
> * 表示层: 将应用处理的信息转换为**适合网络传输的格式**，或将来自下一层的数据转换为上层能够处理的格式；主要负责数据格式的转换，确保一个系统的应用层信息可被另一个系统应用层读取
> * 会话层：**负责建立和断开通信连接**（数据流动的逻辑通路），记忆数据的分隔等数据传输相关的管理
> * 传输层: (数据段)只在通信双方的节点上（比如计算机终端）进行处理，而无需在路由器上处理，传输层是OSI中最重要、最关键的一层,是唯一负责总体的数据传输和数据控制的一层.
> * 网络层：(数据包)将数据传输到目标地址；目标地址可以使多个网络通过路由器连接而成的某一个地址，主要负责寻找地址和路由选择，网络层还可以实现拥塞控制、网际互连等功能
> * 数据链路层: (数据帧)负责物理层面上的互联的、节点间的通信传输（例如一个以太网项链的2个节点之间的通信）；该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
> * 物理层：负责0、1 比特流（0/1序列）与电压的高低、逛的闪灭之间的转换

![image-20230907221226178](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230907221226178.png)

![image-20230907220908695](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230907220908695.png)

### 循环队列

在循环队列中，元素个数的计算方法通常是：`(rear - front + maxSize) % maxSize。`

这里的 rear 和 front 指的是队列的尾指针和头指针的位置。maxSize 指的是队列的最大容量。在计算元素个数时，我们首先将 rear 减去 front，然后再加上 maxSize 再取模。

这样可以保证即使 front 比 rear 大（也就是说，rear 在 front 前面），我们也可以正确地计算出元素个数。

### 友元函数

友元函数是单向的,A是B的友元,但是B不一定是A的友元.

友元函数是不具有传递性的.A是B的,B是C的,A不一定是C的.
