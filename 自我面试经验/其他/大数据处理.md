![image-20230616150200890](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230616150200890.png)

## 分段统计思想

##### 如何使用1G内存找出42亿个整数中词频最多的数

- 首先,使用经典的**哈希函数**是不能实现的,`<int,int>`一条记录最少8B,如果最差情况42亿个数都不一样,需要42亿*8B=32G内存空间,不满足条件.

- 所以,我们使用HashFunc函数,某一个数`A->HashFunc->B值`,`B值%100->C`,那么C一定是在0~100区间内的数.
- 通过这种方式**将42亿个数分配到100个文件**当中,**相同的数一定在同一个文件中**,分别记录每一个文件中词频最大的数,空间释放走下一个文件,然后取100个文件的词频最大值.每一次空间需要`32G/100<1G.`
- B值相同导致的冲突问题是无所谓的,两个不同的数字到底也是不同的,只不过因为HashFunc冲突被分配到同一个文件罢了.


### 位图思想

![image-20230616115007216](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230616115007216.png)

**2^32 用位图**,即1bit表示一个数是否出现过,而1Byte=8bit,所以需要内存空间是

`2^32 /8/1024/1024=512MB<1GB.`

##### 再进阶内存限制是3KB

我想用`unsigned int[N]`类型开一个数组用来表示,因为int是4B,

在不超内存的情况下就是**3KB/4B=768**,最接近2的9次方即512大小.

所以取N=512,开辟数组int [512].

如果将2^32个数均分到数组中,每一个数组元素int类型用来记录次数,均分得到的数字个数是`2^32/512=8,388,608`个,也就是说只要是出现在[0,8,388,608]范围出现的数,arr[0]++统计次数.

因为是40亿个数,那么肯定**有一个元素统计的次数小于8,388,608**,我们就确定了是哪个区间出现的数字缺失.

之后我们清空内存,用3KB 空间以上述同样做法,去递归判断进一步缩小哪一个区间缺失值,直到确定某一个数的缺失.

##### 再进阶只能申请有限几个变量

那么我们就开辟2个,x记录`[0,2^32/2]`出现的次数,y记录另外一半出现的次数,因为只有40亿个数,所以`一定会有一个变量的值<2^32/2`,同理,清理内存之后,根据确定的区间持续二分下去.最多过32次这个文件即可.

#### 32位无符号整数的范围是0~4294967295， 现在有40亿个无符号整数， 找出所有出现了两次的数。  可以使用最多1GB的内存.

两个位图表示一个数字出现的状态,01代表出现1次. 2^32个数字,用2位信息表示一个数,因为是bit,2^32*2/8在1G空间是可以实现的.

### 范围统计

#### 可以使用最多10MB的内存， 怎么找到这40亿个整数的中位数？  (范围统计)

我想用unsigned int[N]类型开一个数组用来表示,因为int是4B,那么在不超内存的情况下就是`10KB/4B=2560`最接近2的11次方即2048大小.所以取N=2048,开辟数组int [2048]

如果将2^32个数均分到数组中,每一个数组元素int类型用来记录次数,均分得到的数字个数是`2^32/2048=2,097,152`个,也就是说

- 只要是出现在[0,2,097,152]范围出现的数,arr[0]++统计次数.
- 在[2,097,153,2*2,097,152-1]范围内arr[1]++;

求中位数,**将前x项进行累加累加和sum<20亿,**当到x+2项累加和超过20亿,那么就可以确定中位数就在x+1这个项中,就知道想在arr[x+1]中找第20亿-sum个数即可.

### 堆和外排序

#### 1. 某搜索公司一天的用户搜索词汇是海量的(百亿数据量)， 请设计一种求出每天热门Top100词汇的可行办法  

1. 百亿数据在一个文件中,可以根据内存限制对数据进行分类,比如分为100个小文件,
2. 根据哈希表对每一个小文件进行词频统计,统计的数据情况放到一个大根堆中以词频出现频率为key,这样形成了100个大根堆.
3. 之后再将每一个大跟堆中堆顶元素统一整合到总的大根堆中.这样,如果堆顶弹出一个元素之后,由他原来堆再进行补充新的堆顶元素,然后总堆再进行调整.

#### 2. 10G文件硬盘,每个文件中都是有符号整数,无序,如果只有5G内存,如何输出进一个文件使得有序.

维护一个小根堆,是根据数值大小组织的,然后记录每个数值的出现次数.

记录每条数据需要至少8字节,考虑到堆维护的消耗,可有一定的增大,比如就是16字节.

那么在5G内存时能够使得堆中数据是`5G /16=5*2^26`,最近的2的倍数就是`2^28次`方条记录.

* 问题: 如何保证最小的那2^28个数在一个区间当中?

遍历时发现是<2^28的数放到第一个区间中即可.不断更新阈值即可将应该在哪里的数字分配到指定区间.

* 使用小跟堆得到的是最大的那K个数,排的是降序,使用大跟堆得到的是最小的那K个数,排的是升序

##### 法一:范围统计

有符号整数范围是[-2^31~2^32-1],那么就可以分为`2^32*2/2^28=2^5`这么些等分,先用小根堆统计第一份数字的情况,比如是[-2^31,-2^31+2^28-1],然后输出到一个文件中.清理内存再去统计下一份数据情况即数据种类以及对应的词频统计,输出到文件中.....

##### 法二:阈值统计

使用大根堆限制每次统计文件中Y值以下的数的词频情况.

假设现在只有10个数,限制**大根堆**中能够统计的数据个数是3个,

当不足3个数据统计时入堆,如果数字相同,词频统计加加,最后一遍之后得到**最小的三个数**的词频情况,按照大小排序之后按照词频输出到文件中,

**然后将Y值设置为三个数中最大值,然后再走一遍文件.**

下一次走文件的时候,只要是<=Y的数字不用看了,因为已经统计完了,周而复始.

同理,只有5G内存供你维护堆结构,那么估算堆能够统计2^28条记录,那么走一遍文件之后就可以得到**最小的那2^28个数**的词频情况,排序之后输出到文件中,**设置Y阈值**,再走一遍文件再输出,再更新Y阈值,周而复始,就可完成目的.