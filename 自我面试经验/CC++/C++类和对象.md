### 深浅拷贝

1. 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说**源对象和目标对象共用一份实体**，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。

2. 深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误

```C++ 
class String
{
private:
	char* str;
public:
	String()
		:str(new char(4))
	{}
	String(char* s)
		:str(s)
	{}
public:
	String(const String& s)
	{
		//浅拷贝
		//str = s;
		//深拷贝
		str = new char(strlen(s.str) + 1);
		strcpy(str, s.str);
	}
	String& operator=(const String& s)
	{
		if (this != &s)
		{
			delete str;
			str = new char(strlen(s.str) + 1);
			strcpy(str, s.str);
		}
		return *this;
	}
};
```



### 虚函数表中内容什么时候写入

1. 虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vftable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vfptr，然后调用构造函数。即：**虚表在构造函数之前写入**

2. 除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。

### 哪些函数不能被定义为虚函数

1. 构造函数

   * 因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）

   * 构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数

2. 静态函数

   * 静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。
   * 静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别

3. 内联函数

   * 内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数
   * 虚函数需要将虚函数地址写到表中,内联函数没有地址无法写入,也就无法再运行时动态调用.

4. 友元函数

   * 因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

5. 普通函数(非成员函数)

   *  普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数

### 拷贝赋值 移动赋值

1. 拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。

2. 移动赋值是通过移动构造函数来赋值，二者的主要区别在于
   1. 拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；
   2. 拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。

* 被虚拟继承的类叫做虚基类

### 抽象类

1. 抽象类的定义如下：

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。

2. 抽象类有如下几个特点：

> 1）抽象类只能用作其他类的基类，不能建立抽象类对象。
>
> 2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。
>
> 3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。

#### 虚函数和纯虚函数的区别

1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。

2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。

3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。

4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。

5. 虚函数的定义形式： virtual{} ;纯虚函数的定义形式： virtual { } = 0 ;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。

### 构造函数中调用虚函数

不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。

派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。所以，虚函数始终仅仅调用**基类的虚函数**（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果

### 常量函数的作用

- 类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。
- 在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。
- 所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。
- 除此之外，在类的成员函数后面加 const 还有什么好处呢？
- * 那就是常量（即 const）对象可以调用const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。

### 构造函数为什么不能是虚函数

1. 从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）

2. 从使用角度：虚函数主要用于在**信息不全的情况下，能使重载的函数得到对应的调用**。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。
   * 虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。

3. 从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

#### 构造函数为什么不是虚函数

在C++中，构造函数不能是虚函数，这是因为虚函数的调用是通过对象的虚函数表（vtable）来实现的，而**构造函数在对象创建时被调用，此时虚函数表还未被构造。因此，虚函数在构造函数中无法被正确地调用。**

当创建一个对象时，会先**分配内存空间并初始化对象的成员变量**，然后调用构造函数来执行进一步的初始化操作。**在构造函数的执行过程中，对象尚未构造完成，此时无法确定该对象的虚函数表的地址**，因此无法进行虚函数调用。

另外，**构造函数和析构函数都不会继承，它们没有父子关系。所以，虚函数的特性不适用于构造函数。**

如果在基类中定义了虚函数，派生类的构造函数中会首先调用基类的构造函数，但**此时派生类对象的虚函数表还是空的**。只有**在派生类构造函数执行完成后，对象才算构造完成，此时虚函数表被正确地设置。**

综上所述，由于构造函数在对象构造期间执行，无法访问虚函数表，因此构造函数不能是虚函数。

### 类内定义引用成员变量

引用数据成员是指在类中定义的一个变量，它的类型为其他变量或对象的引用。

引用数据成员必须在类的构造函数中进行初始化，并且一旦初始化后，它将一直引用同一个对象。

引用数据成员一般用于需要对外部对象进行操作或访问的情况，可以简化代码实现，提高效率。

```C++
class MyClass 
{

public:
	MyClass(int& r)
		:ref(r)
	{}
	void print()
	{
		cout << "ref= " << ref << endl;
	}
private:
	int& ref;
};
int main()
{
	int x = 10;
	MyClass obj(x);
	obj.print();//10
	x = 20;
	obj.print();//20,对象中引用随着外部变量更改,它也更改了
	return 0;
}
```

在上面的代码中，MyClass 类定义了一个 int 类型的引用数据成员 ref，通过构造函数将 ref 引用传递进来的参数 r 进行初始化。printRef() 函数可以访问引用数据成员 ref 的值，并将其打印到标准输出中。

需要注意的是，引用数据成员不能作为类的成员变量的初始值列表中的成员进行初始化，因为引用必须在声明时就进行初始化。

此外，引用数据成员也不能重新赋值，因为引用一旦指向了某个对象，就不能再改变其指向的对象.