#### longlong和long

在 C++ 中，"long long" 和 "long" 是两种整数数据类型，用于表示整数值，但它们的大小和范围有所不同。以下是它们的主要区别：

1. 大小和范围：
   - "long"：通常是 32 位（4 字节），范围约为 -2^31 到 2^31-1。在大多数平台上，"long" 和 "int" 的大小相同。
   - "long long"：通常是 64 位（8 字节），范围约为 -2^63 到 2^63-1，这是一个非常大的范围，远远超过了 "long" 的范围。

2. 内存占用：
   - "long" 和 "long long" 占用的内存空间不同，"long" 通常是 4 字节，而 "long long" 通常是 8 字节。因此，"long long" 使用的内存比 "long" 多。

3. 用途：
   - "long" 适用于大多数情况，用于表示较大的整数值，而不需要超出 32 位的范围。
   - "long long" 主要用于处理非常大的整数值，例如在涉及大型整数计算或需要更大范围的情况下。

示例（在C++中）：

```cpp
#include <iostream>

int main() {
    int a = 2147483647;
    long b = 9223372036854775807;
    long long c = 9223372036854775807;

    std::cout << "int a: " << a << std::endl;
    std::cout << "long b: " << b << std::endl;
    std::cout << "long long c: " << c << std::endl;

    return 0;
}
```

注意：在 C++11 中引入了 "long long" 数据类型。在早期版本的 C++ 中，可能没有 "long long" 数据类型支持。而在现代的 C++ 编译器中，通常都支持 "long long" 数据类型。为了确保代码的可移植性，可以使用 `<cstdint>` 头文件中的 `int64_t` 和 `int32_t` 等固定大小的整数类型来代替 "long long" 和 "long"，这样可以保证整数类型的大小在不同平台上是一致的。

#### 指针和引用的区别

定义:

- 指针：**指针是一个变量，其值为另一个变量的地址**。定义指针时需要使用星号（*）来标识该变量是一个指针。例如：`int* ptr;` 定义了一个指向整数类型的指针。
- 引用：**引用是一个已存在变量的别名，它与原始变量共享同一内存地址。**在定义引用时不需要使用特殊符号，只需在变量名前加上引用符号（&）

1. 空值

指针：指针可以是空指针，即指向空地址或未初始化的指针。空指针的值为 nullptr（C++11之后）或 NULL（较早的C++版本）。表示空指针时，不指向任何有效的内存地址。

引用：引用必须在定义时初始化，并且不能指向空值。引用始终引用某个已经存在的对象，不能单独存在。

初始化列表

2. 重新赋值

指针：指针可以在其生命周期内重新赋值，指向不同的地址。例如：`int* ptr = # ptr = &another_num;` 可以将指针 ptr 重新指向另一个整数变量。

引用：一旦引用与某个变量绑定，就不能再改变其引用的对象。引用在初始化后不能被重新绑定到其他对象。

3. 空间大小

指针：指针变量本身占用一定的内存空间，通常是指针大小（在32位系统上为4字节，在64位系统上为8字节）。

引用：引用不占用额外的内存空间，因为它只是变量的别名，与原变量共享同一地址。

4. 指针变量有自己的地址,可以对指针进行操作.引用没有专属于自己的地址.

5. 函数参数传递：
   - 指针：可以将指针作为函数的参数传递，从而在函数内部修改指针指向的值或地址。
   - 引用：可以将引用作为函数的参数传递，通过引用修改函数外部的变量

#### 解释一下什么叫多态

编译时多态（静态多态性）：通过**函数重载和运算符重载**来实现。函数名相同,在编译时，根据**参数的类型**或**运算符的操作数类型**来确定具体调用的函数或运算符函数。

模版属于编译时多态.

运行时多态（动态多态性）：通过虚函数（Virtual Function）和指针或引用来实现。在运行时，根据实际对象的类型来确定调用的函数。本质就是不同类型的对象调用同一个函数,展现出不一样的效果.是通过虚函数表实现的.

* 运行时多态的条件:父类的指针或引用调用+派生类对父类中的函数发生重写.
* 重写=三同+是虚函数.函数名+返回值+参数类型都相同.并且函数受到virtual修饰.

虚函数:被virtual修饰的成员函数,是类的非静态成员函数.

##### 析构函数为什么被设置为虚函数

析构函数的函数名会被统一处理为相同的destructer,不设置为虚函数也是会构成隐藏的.如果是普通的析构函数,是否是虚函数发生重写都可以正确调用.

但是如果是动态申请的父子对象,并且给了**父类指针**管理,需要构成多态.

#### C++11补充的关键字

C++11引入了一些新的关键字和功能，以增强语言的功能和表达能力。以下是C++11中一些新增的关键字和功能：

1. `auto`: 自动类型推导。可以让编译器根据初始化表达式的类型自动推断变量的类型。
2. `nullptr`: 空指针字面量。用于表示空指针，取代了C++03中的NULL宏。
3. `constexpr`: 常量表达式。用于在编译时求值的表达式，可以用于声明常量、数组大小等。
4. `decltype`: 表达式类型推导。用于获取表达式的类型而不执行表达式。
5. `lambda`: **匿名函数**。允许在代码中定义匿名的、可调用的函数对象。
6. `nullptr`: 空指针。用于表示空指针常量，取代了C++03中使用的NULL宏。
7. `override`: 覆盖函数。在派生类中表明该函数覆盖了基类中的虚函数。
8. `final`: 最终类和函数。在类和函数声明中用于标识它们是最终的，不能再被派生或覆盖。
9. `default`和`delete`: 用于控制默认的构造函数、拷贝构造函数、移动构造函数和赋值运算符的生成和删除。
10. `using`: 别名声明。用于创建类型别名或引入命名空间成员。
13. `constexpr`: 常量表达式。用于标识函数或变量可以在编译时计算。

#### Linux环境常见指令

在Linux系统中，一键关机的指令是`shutdown`。使用`shutdown`命令可以安全地关闭或重启系统，并且可以预定关机或重启的时间。

常见的一键关机指令格式如下：

```bash
shutdown [选项] 时间 [警告信息]
```

其中，`选项`是一些可选参数，`时间`是指定关机或重启的时间，`警告信息`是向所有用户发送的提前警告消息。

例如，要立即关机，可以使用以下指令：

```bash
sudo shutdown now
```

要在5分钟后关机，可以使用以下指令：

```bash
sudo shutdown -h +5
```

要向所有用户发送关机警告消息，并在10分钟后关机，可以使用以下指令：

```bash
sudo shutdown -h +10 "系统将在10分钟后关机，请保存好您的工作。"
```

请注意，使用`shutdown`命令需要管理员权限，因此需要在指令前加上`sudo`（如果你有管理员权限）。此外，为避免误操作，关机前建议保存所有未保存的工作。

在Linux环境中，你可以使用以下命令来**查看内存使用情况**：

1. `free`: `free` 命令用于显示系统的内存使用情况，包括**物理内存和交换区**（swap）的使用情况。

   ```bash
   free -h
   ```

   使用 `-h` 选项可以以人类可读的格式显示内存大小（以GB、MB等单位）。

2. `top`: `top` 命令用于实时显示系统的资源使用情况，包括内存、CPU、进程等。

   ```bash
   top
   ```

   在 `top` 命令的界面中，按下 `Shift + M` 可以按内存使用量对进程进行排序，显示内存占用最高的进程在最上面。

3. `htop`: `htop` 是 `top` 命令的增强版，提供更多的功能和交互选项。

   ```bash
   htop
   ```

   与 `top` 类似，`htop` 可以实时显示系统的资源使用情况，但其界面更友好，并且提供了更多的交互选项。

4. `vmstat`: `vmstat` 命令用于显示**虚拟内存统计信息**，包括内存、交换区、磁盘和CPU等统计数据。

   ```bash
   vmstat
   ```

这些命令可以帮助你快速查看Linux系统的内存使用情况，以便及时发现内存压力，优化系统性能或查找可能的内存泄漏问题。

在C++面试中，如果面试官让你简单介绍一下Linux环境的常见指令和功能，你可以提及以下几个常见的Linux指令及其功能：

1. `ls`: 列出目录内容。用于显示当前工作目录中的文件和子目录列表。

2. `cd`: 切换目录。用于进入到指定的目录。

3. `pwd`: 显示当前工作目录的路径。

4. `mkdir`: 创建目录。用于创建新的目录。

5. `rm`: 删除文件或目录。用于删除指定的文件或目录。

6. `cp`: 复制文件或目录。用于将文件或目录从一个位置复制到另一个位置。

7. `mv`: 移动文件或目录。用于将文件或目录从一个位置移动到另一个位置，也可以用于文件或目录的重命名。

8. `cat`: 查看文件内容。用于查看文件的内容，也可以用于多个文件合并显示。

9. `grep`: 文本搜索工具。用于在文件中查找指定的文本模式。

10. `ps`: 查看进程信息。用于显示当前系统正在运行的进程信息。

11. `kill`: 终止进程。用于向指定进程发送信号来终止它。

12. `top`: 动态查看进程信息。用于实时显示当前系统中的进程和系统资源使用情况。

13. `chmod`: 修改文件权限。用于改变文件的访问权限。

14. `chown`: 修改文件所有者。用于改变文件或目录的所有者。

15. `tar`: 压缩和解压缩文件。用于打包文件或目录，以及解压缩tar包。

以上列出的是一些常见的Linux命令，当然Linux环境中还有很多其他有用的命令和功能。在面试时，简要介绍这些常用指令，展示你对Linux环境的基本熟悉程度。如果面试官对特定的Linux命令有更深入的问题，你可以进一步展开讨论。

#### 进程地址空间

进程地址空间是操作系统中的一个重要概念，它是每个正在运行的进程独有的虚拟内存空间。每个进程都有自己的地址空间，使得每个进程在执行过程中互相隔离，不会直接访问其他进程的内存。进程地址空间由以下几个主要部分组成：

1. 代码段（Text Segment）：也称为只读代码段。该部分包含了正在运行的可执行程序的机器指令，通常是程序的可执行文件在内存中的映像。由于代码段通常是只读的，因此防止了程序意外修改自身的指令。

2. 数据段（Data Segment）：数据段包含已初始化的全局变量和静态变量。这些变量在程序启动时已经被赋予了初值，并在整个程序的执行过程中保持不变。

3. BSS段（BSS Segment）：BSS段包含未初始化的全局变量和静态变量。这些变量在程序启动时并不占用实际的物理存储，而是在程序开始执行时由系统初始化为0或空值。

4. 堆（Heap）：堆用于动态分配内存空间，通常由程序员在运行时进行手动分配和释放。在堆中分配的内存可以在程序的整个生命周期内保持，直到显式释放或程序结束。

5. 栈（Stack）：栈用于存储函数调用的局部变量和函数的调用信息。每次函数被调用时，都会在栈上分配一块内存用于保存局部变量，当函数返回时，这些内存将被释放。栈是一种后进先出（LIFO）的数据结构。

进程地址空间的设计使得操作系统可以有效地管理多个进程并提供进程间的隔离，从而增加系统的稳定性和安全性。每个进程都认为自己是在独占的地址空间中运行，而不需要担心其他进程的存在。这样，进程之间的互相影响被最小化，确保了系统的正常运行。

#### 环境变量

环境变量是计算机操作系统中的一种重要概念，它是为了**方便管理系统配置和运行时参数而设立的一种机制**。环境变量是一组键值对（Key-Value pairs），用于存储操作系统和应用程序的配置信息，例如系统路径、默认语言、临时目录等。

在理解环境变量时，以下几个关键点很重要：

1. **全局性**：环境变量是全局性的，它在**整个操作系统中都可用**，并可以被系统中的所有进程访问。这使得不同的进程能够共享相同的配置信息，而不需要每个进程单独进行配置。

2. **动态性**：环境变量是动态的，它可以在系统运行时被修改和更新。这意味着管理员或用户可以根据需要更改环境变量的值，从而影响系统和应用程序的行为。

3. **优先级**：环境变量具有优先级，当多个环境变量的键名相同时，系统会根据一定的优先级规则来选择使用哪个值。例如，用户设置的环境变量通常比系统默认设置的环境变量优先级更高。

4. **影响应用程序行为**：环境变量对于应用程序的行为具有重要影响。许多程序会根据特定的环境变量的值来调整其运行方式，例如根据`PATH`环境变量来查找可执行文件的位置。

在不同的操作系统中，设置和使用环境变量的方法可能有所不同。在Linux和Unix系统中，可以使用`export`命令设置环境变量，例如：

```bash
export MY_VAR="Hello"
```

而在Windows系统中，可以使用`set`命令来设置环境变量，例如：

```batch
set MY_VAR=Hello
```

总的来说，理解环境变量是理解操作系统和应用程序配置管理的重要一环，它为我们提供了一种简便而灵活的方式来控制系统和程序的行为。