### extern 

在C++中，`extern` 是一个关键字，用于声明外部变量和函数。它的作用是指示编译器该变量或函数是在其他地方定义的，而不是在当前文件中定义。这可以用于在多个源文件中共享变量或函数的定义。

具体来说，`extern` 关键字的作用有以下几个方面：

1. **声明外部变量：** 当你需要在一个源文件中使用另一个源文件中定义的全局变量时，可以使用 `extern` 来声明该变量，告诉编译器该变量是在其他地方定义的。这样，编译器就知道在链接阶段去寻找该变量的实际定义。

2. **声明外部函数：** 类似地，当你**需要在一个源文件中调用另一个源文件中定义的函数时**，可以使用 `extern` 来声明该函数。这样编译器就知道在**链接阶段**去寻找函数的实际定义。

3. **避免重复定义：** 在C++中，每个源文件都是一个独立的编译单元。如果你在多个源文件中都定义了同名的全局变量，链接阶段会导致重复定义错误。通过在一个源文件中定义变量，然后在其他文件中使用 `extern` 来声明该变量，**可以避免这种重复定义问题**。

下面是一个示例：

在 "file1.cpp" 中定义全局变量：

```cpp
// file1.cpp
int globalVar = 10;
```

在 "file2.cpp" 中使用 `extern` 来声明全局变量并使用：

```cpp
// file2.cpp
extern int globalVar;  // 声明外部变量
#include <iostream>

int main() {
    std::cout << "Global variable: " << globalVar << std::endl;
    return 0;
}
```

在这个示例中，使用 `extern` 声明了在 "file1.cpp" 中定义的全局变量 `globalVar`，从而在 "file2.cpp" 中可以访问它，而不需要重新定义。

## 判断IP地址是否合法


判断IP地址是否合法涉及多个方面，以下是一些应该考虑的关键点：

1. **格式验证：** IP地址应该按照"X.X.X.X"的格式，其中X代表0到255之间的整数。每个X之间用点号（.）分隔。
2. **段数验证：** IP地址由四个段组成，每个段用点号分隔。确保IP地址具有四个段。
3. **段内字符验证：** 每个段内的字符应该只包含数字字符。即每个段应该由纯数字组成。
4. **段范围验证：** 每个段的数字应该在0到255之间（包括0和255），这是IPv4地址的范围。
5. **段前导零验证：** 段中的数字不应该有前导零，例如"01"是不合法的。
6. **其他字符验证：** IP地址中只允许数字和点号，不应该包含其他字符。

## 死锁解决

### 哲学家进餐问题

哲学家问题（Dining Philosophers Problem）是一个经典的并发编程问题，用来探讨在多线程或多进程环境中如何有效地解决资源竞争和死锁等并发编程中的挑战。

问题的背景是：有五位哲学家围坐在圆桌旁，每个哲学家面前放着一碗意大利面和一只叉子。哲学家需要交替地思考（即不进行任何操作）和进餐（即同时拿起两只相邻叉子，并吃完意大利面后放下叉子）。每个哲学家只有在同时拿到他左右两边的叉子时才能进餐。问题的关键在于如何确保哲学家能够正确地进餐，避免死锁（所有哲学家都无法同时拿到两只叉子）和资源竞争（多个哲学家试图争夺同一只叉子）。

解决哲学家问题的方法之一是使用同步机制，如互斥锁（Mutex）和条件变量（Condition Variable）。以下是一种可能的解决方案：

1. 每只叉子都可以用一个互斥锁来表示，用来保证一次只有一个哲学家可以拿起或放下叉子。

2. 每个哲学家在进餐之前，首先尝试获取左右两边的叉子，如果不能同时获取两只叉子，则释放已经获取的叉子，进入等待状态。

3. 当一个哲学家成功拿起两只叉子后，进餐一段时间，然后放下叉子，释放互斥锁，使其他哲学家可以继续竞争叉子。

这种解决方案确保了每个哲学家都能够以安全的方式进餐，避免了死锁和资源竞争问题。然而，需要仔细设计和实现以确保互斥锁和条件变量的正确使用，以及避免潜在的竞态条件。

哲学家问题在并发编程中是一个经典的示例，用来说明多线程或多进程环境中的同步和协调的挑战，以及如何通过适当的同步机制来解决这些挑战。

### 银行家算法

银行家算法（Banker's Algorithm）是一种用于避免死锁的资源分配和调度算法，特别适用于多进程或多线程系统中的资源管理。它基于预先分析系统中的资源需求和可用资源数量，以确保在分配资源时不会导致死锁的发生。

银行家算法的原理可以概括如下：

1. **系统状态描述：** 银行家算法要求系统管理员提前提供每个进程的最大资源需求量、已分配资源量和当前需要资源量。此外，还需要记录系统当前的可用资源数量。

2. **安全性检查：** 在任何时刻，系统管理员都可以执行安全性检查来确定是否可以分配资源，而不会导致死锁。安全性检查基于银行家算法的一个重要性质，即系统必须保证在给定资源分配的情况下，至少存在一种执行顺序，使得所有进程都能够成功完成。

3. **资源分配决策：** 当一个进程请求一定数量的资源时，系统管理员会先检查分配这些资源是否会使系统变得不安全（即可能导致死锁）。如果分配不安全，则拒绝分配资源；如果分配安全，则首先将资源分配给进程，并更新系统状态。

4. **资源释放：** 当进程完成任务并释放资源时，系统管理员会相应地更新系统状态，将释放的资源添加到可用资源数量中，以备其他进程使用。

银行家算法的主要目标是确保资源分配是安全的，即分配资源后不会进入死锁状态。为了达到这个目标，银行家算法使用了一种叫做安全性序列的方法，通过找到一个安全序列，证明在这个序列下，所有进程都能够完成，并最终释放它们所拥有的资源。

要注意的是，银行家算法需要提前了解每个进程的最大资源需求量，这在实际情况中可能并不总是容易得到，也会引入一些开销。此外，银行家算法只是避免死锁的一种方法之一，还有其他许多死锁避免和处理的策略。

## 消息队列

消息队列（Message Queue）是一种在分布式系统中**用于异步通信的通信模式**。它允许不同的组件、服务或应用程序之间通过发送和接收消息来进行解耦和通信。消息队列的主要目的是**将发送者和接收者的时间解耦，从而提高系统的可伸缩性、可靠性和灵活性。**

在消息队列中，消息被发送到队列中，然后由接收者从队列中获取并处理。这使得**发送者和接收者可以独立地运行，不需要直接交互，从而避免了直接的同步通信和耦合**。消息队列可以用于许多不同的应用场景，包括：

1. 异步任务处理：将耗时的任务放入消息队列中，以便后台处理，而不阻塞主应用程序的执行。

2. 松耦合系统：不同的微服务或模块可以通过消息队列进行通信，而无需了解彼此的具体实现细节。

3. 流量削峰：在高峰时段，消息队列可以帮助缓解系统压力，将请求排队处理，防止系统过载。

4. **数据同步：不同系统之间的数据同步可以通过消息队列来实现，确保数据的一致性和可靠性。**

5. 日志传输：将日志消息发送到消息队列中，以便集中存储和分析。

6. 事件驱动架构：通过订阅和发布消息，实现基于事件的系统架构。

## 乐观锁与悲观锁

前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。

悲观锁做事比较悲观，它认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁**。

那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。

乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。

放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。

可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现**乐观锁全程并没有加锁，所以它也叫无锁编程**。

这里举一个场景例子：在线文档。

我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。

那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。

怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交早，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。

服务端要怎么验证是否冲突了呢？通常方案如下：

- 由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；
- 当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号不一致则提交失败，如果版本号一致则修改成功，然后服务端版本号更新到最新的版本号。

实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。

乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。**

> CAS 不是乐观锁吗，为什么基于 CAS 实现的自旋锁是悲观锁？

乐观锁是先修改同步资源，再验证有没有发生冲突。

悲观锁是修改共享数据前，都要先加锁，防止竞争。

CAS 是乐观锁没错，但是 CAS 和自旋锁不同之处，自旋锁基于 CAS 加了while 或者睡眠 CPU 的操作而产生自旋的效果，加锁失败会忙等待直到拿到锁，**自旋锁是要需要事先拿到锁才能修改数据的**，所以算悲观锁。

#### Linux命令补充

在Linux系统中，有许多常用的命令可以用于查看不同类型的资源使用情况。以下是一些常见的命令，用于查看内存资源、磁盘资源以及其他资源的使用情况：

**内存资源：**

1. `free`：显示系统的物理内存和交换空间使用情况。

   ```bash
   free -h
   ```

   `-h` 参数将结果以易读的格式显示。

2. `top`：动态地显示系统中各个进程的资源使用情况，包括内存、CPU等。

   ```bash
   top
   ```

   按下`Shift`+`M`可以按内存使用量排序进程。

3. `htop`：类似于top，但提供了更多的交互和信息展示功能。

   首先，你需要安装htop（如果尚未安装）：

   ```bash
   sudo apt-get install htop  # 对于Debian/Ubuntu系统
   sudo yum install htop      # 对于CentOS/RHEL系统
   ```

   安装完成后，运行以下命令来使用htop：

   ```bash
   htop
   ```

**磁盘资源：**

1. `df`：显示文件系统磁盘空间使用情况。

   ```bash
   df -h
   ```

   `-h` 参数将结果以易读的格式显示。

2. `du`：查看文件和目录的磁盘使用情况。

   ```bash
   du -h /path/to/directory
   ```

   `-h` 参数同样将结果以易读的格式显示。

3. `ncdu`：交互式地查看磁盘使用情况。

   安装和使用方式在前面的回答中已经提到过。

**其他资源：**

1. `top`：除了内存和CPU使用情况外，top还可以查看系统的负载平均值等信息。

2. `uptime`：显示系统的负载平均值、运行时间等信息。

   ```bash
   uptime
   ```

3. `netstat`：查看网络连接和统计信息。

   ```bash
   netstat -tuln
   ```

4. `ifconfig` 或 `ip`：查看网络接口的配置和状态信息。

   ```bash
   ifconfig
   ```

   或

   ```bash
   ip addr
   ```

这些命令可以帮助你在Linux系统中查看不同类型的资源使用情况。根据你的需求，选择适合你的方法来获取所需的信息。