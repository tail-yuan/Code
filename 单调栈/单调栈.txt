最经典的用法就是查找一个无序数组当中,O(1)时间获取
index位置左右两侧距离自己最近并且比自己大(小)的元素是谁
整体的时间复杂度缩小到O(N),单次操作的平均时间复杂度是O(1)
数组中无重复值时:
举例: 如果是寻找比自己小的元素,那么单调栈中需要维护从栈底到顶从小到大的顺序,
1. 当栈为空,或者栈顶元素比自己小时直接进
2. 发现index+1位置比自己小,弹出栈顶元素cur,那么左侧比自己小的元素是此时的栈顶,
右侧比自己小的就是index+1位置.记录cur寻找的两个元素之后,
将index+1位置放入单调栈中,维护从小到大的单调性.
3.当遍历数组完成时,数组进行清算环节,栈顶就是最后一个元素,就没有右侧比自己小的元素.
当存在重复值时,https://www.bilibili.com/video/BV1HH4y1X7T9?t=1629.3
index+1位置x发现和栈顶元素cur相等时,仍然弹出,cur右侧比自己小的为x,但是标记为时不正确的
因为是相等的,整个过程走完之后,因为从左往右走,左侧最小值一定是正确的,
右侧比自己小的并且标记为不正确(因为相等弹出时),直接等于和自己相等的值x的右侧比他小的值
每个位置进栈出栈各一次,时间复杂度仍然是O(N)

除了单调栈最经典的用法之外，在很多问题里单调栈还可以 维持求解答案的可能性
1)单调栈里的所有对象按照 规定好的单调性来组织
2)当某个对象进入单调栈时会从栈顶开始 依次淘汰单调栈里 对后续求解答案没有帮助 的对象
3)每个对象从栈顶弹出的时 结算当前对象参与的答案，随后这个对象 不再参与后续求解答案的过程
4)其实是 先有对题目的分析!进而发现单调性，然后利用 单调栈的特征 去实现