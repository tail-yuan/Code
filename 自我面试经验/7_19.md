#### strcpy vs strnpy

`strcpy`和`strncpy`是C语言中用于字符串操作的函数，它们的主要区别在于字符串复制的方式和安全性。

1. strcpy (String Copy):
   `strcpy`是字符串复制函数，用于将一个字符串从源地址复制到目标地址，直到遇到字符串结束符`\0`为止。其原型如下：
   
   ```c
   char* strcpy(char* destination, const char* source);
   ```
   - `destination`: 目标字符串的指针，指向要复制到的内存区域。
   - `source`: 源字符串的指针，指向要复制的字符串。
   
   但是需要注意，`strcpy`不会检查目标缓冲区是否足够大，如果目标缓冲区不够大，可能会导致缓冲区溢出的问题，从而造成程序崩溃或安全漏洞。因此，使用`strcpy`时要确保目标缓冲区足够大以容纳源字符串及其结尾的空字符。
   
2. strncpy (String Copy with Length Limitation):
   `strncpy`也是字符串复制函数，但它会限制复制的最大长度。其原型如下：
   
   ```c
   char* strncpy(char* destination, const char* source, size_t num);
   ```
   - `destination`: 目标字符串的指针，指向要复制到的内存区域。
   - `source`: 源字符串的指针，指向要复制的字符串。
   - `num`: 要复制的最大字符数。
   
   `strncpy`会将源字符串中的最多`num`个字符复制到目标字符串中，但有一些需要注意的地方：
   - 如果源字符串长度小于`num`，`strncpy`会用**空字符**填充目标字符串的剩余空间，以保证总共复制了`num`个字符。
   - 如果源字符串`source `长度大于等于`num`，`strncpy`将不会在目标字符串的结尾添加空字符，**可能会导致目标字符串不以空字符结尾。**
   
   由于`strncpy`的行为有时候会导致目标字符串不以空字符结尾，因此一般来说，如果想要安全地复制字符串并确保目标字符串以空字符结尾，可以在使用`strncpy`后手动添加一个空字符，以保证字符串的正确终止。

总结：
- `strcpy`没有长度限制，不安全，容易导致缓冲区溢出。
- `strncpy`有长度限制，但可能不会以空字符结尾，需要额外的处理来确保目标字符串以空字符结尾，以免引起问题。如果目标字符串长度超过`num`，会用空字符填充剩余空间。

#### memcpy vs memmove

在C语言中，`memcpy`和`memmove`函数都用于内存块的复制操作，但它们在处理内存重叠的情况下有不同的行为。

1. memcpy (Memory Copy):
   `memcpy`用于将一个内存块的内容从源地址复制到目标地址。其原型如下：
   
   ```c
   void* memcpy(void* destination, const void* source, size_t num);
   ```
   - `destination`: 目标内存块的指针，指向要复制到的内存区域。
   - `source`: 源内存块的指针，指向要复制的数据。
   - `num`: 要复制的字节数。
   
   `memcpy`是一个简单的内存复制函数，它没有处理内存重叠的能力。如果源地址和目标地址有重叠，`memcpy`的行为是未定义的，这意味着可能会产生不确定的结果。
   
2. memmove (Memory Move with Overlap Handling):
   `memmove`也用于将一个内存块的内容从源地址复制到目标地址，但它可以处理内存重叠的情况。其原型如下：
   ```c
   void* memmove(void* destination, const void* source, size_t num);
   ```
   - `destination`: 目标内存块的指针，指向要复制到的内存区域。
   - `source`: 源内存块的指针，指向要复制的数据。
   - `num`: 要复制的字节数。

   `memmove`会确保在内存重叠的情况下，复制操作能够正确执行。即使源地址和目标地址有重叠，`memmove`也能够正确地处理，保证复制的数据是正确的。

总结：
> - `memcpy`适用于普通的内存复制，但不能处理内存重叠，重叠时行为未定义。
> - `memmove`适用于带有内存重叠的情况，它保证复制操作正确执行，无论内存是否重叠。
>

因此，在使用这些函数时，如果你确定内存不会重叠，可以使用`memcpy`来获得更好的性能。但如果存在内存重叠的可能性，请使用`memmove`以确保正确的复制。

当涉及C++语言时，推荐使用`std::memcpy`和`std::memmove`函数，它们是C++标准库中的对应函数，并且可以与C++对象一起使用。以下是一个简单的例子：

请注意，C++标准库中的`std::memcpy`和`std::memmove`函数都**可以处理任意类型的数据**，不仅限于字符串，它们是通用的内存块复制函数。但是对于C++，更推荐使用`std::string`和相关的标准库函数，因为`std::string`提供了更安全和方便的字符串操作。

```C++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
//strcpy vs strncpy
void test1()
{
	const char* source = "hello world!";//后面默认携带\0
	char dest[20];						//将\0也填充了进去
	strcpy(dest,source);	//strcpy只会将source拷贝进dest中,到\0结尾.
	char dest3[5];
	//strcpy(dest3,source);	//dest3空间不够了,出现崩溃
	cout << "Copied string :" << dest << endl;

	char dest2[30];
	strncpy(dest2,dest,sizeof(source)); //source.size()< dest[20],将source.size个字符放到dest2后,不会默认添加\0,造成崩溃
	//所以最好用完strcnpy之后,手动在结尾处添加\0作为终结标志.注:大小位置size,下标从0开始的话就是size-1
	dest2[sizeof(source)-1]='\0';
	strncpy(dest2,dest,sizeof(dest)); //source.size()< dest[20],所以不够20的部分,strnpy将\0作为默认填充字符,补齐了说好的20个的空缺位置
	cout << "Copied string :" << dest2 << endl;
}
//memcpy vs memmove 
void test2()
{
	const char* source = "hello,world";
	char buffer[20];
	std::memcpy(buffer, source, std::strlen(source)+1);//strlen遇到\0中止,并且不会记录\0个数,所以要+1将\0带上,才是完整字符串
	cout << "memcpy string :" << buffer << endl;//memcpy string : hello, world
	

	char dest[20] = "hello,world";
	char* dest1 = buffer + 4;
	std::memmove(dest1,dest,strlen(dest)+1);
	cout << "memcnpy/memmove string :" << buffer << endl;//memcnpy / memmove string : hellhello, world
		
}
int main()
{
	test2();
}
```

#### 客户端获取数据

当客户端输入一个网址后，它实际上发起了一个HTTP请求来获取客户所需的数据。以下是大致的步骤：

1. DNS解析：客户端将输入的网址发送给本地的DNS服务器，该服务器将解析域名并返回对应的IP地址。这是因为网络通信中需要使用IP地址来确定目标服务器的位置。

2. TCP连接：客户端使用获取到的IP地址建立到目标服务器的TCP连接。TCP是一种可靠的传输协议，确保数据的有序传输和错误处理。

3. 发送HTTP请求：客户端发送HTTP请求到目标服务器。该请求通常包含一些头部信息（如用户代理、请求方法等）和可能的请求体（对于POST请求）。

4. 服务器响应：目标服务器接收到HTTP请求后，会处理请求并返回相应的HTTP响应。响应通常包括状态码（表示请求的成功或失败）、响应头（如数据类型、内容长度等）以及响应体（实际的数据内容）。

5. 数据传输：数据是通过TCP连接在网络中传输的。TCP协议确保数据的可靠性，如果有任何丢失或损坏，TCP会负责重新传输确保完整性。

6. 渲染和显示：客户端接收到服务器返回的数据后，根据内容类型（如HTML、JSON等），进行解析、渲染，并显示在用户界面上，供客户端使用。

值得注意的是，这是一个简化的描述。在实际的网络通信中，还有许多优化和安全机制，例如缓存、压缩、HTTPS加密等，以确保更高效、安全的数据传输和通信。

#### 长地址短地址映射

实现长短地址的互相映射可以通过一个简单的**映射表**（或者数据库）来实现。这个映射表将长地址（原始地址）与短地址（重定向地址）进行对应。当客户端请求**长地址**时，服务器查找映射表获取相应的**短地址**，并将其**重定向**给客户端。当客户端请求**短地址**时，服务器也能够通过映射表查找相应的**长地址**，并提供给客户端。

以下是一个基本的步骤：

1. 客户端请求长地址：当客户端输入长地址时，将其发送到服务器。

2. 服务器处理请求：服务器收到长地址请求后，检查映射表（或数据库）中是否存在该长地址的短地址。

3. 生成短地址：如果映射表中不存在该长地址的短地址，服务器会生成一个新的短地址。这个过程可以使用某种算法，比如基于哈希函数的方法，**确保生成的短地址是唯一的**。

4. 将映射写入数据库：服务器将长地址和新生成的短地址的对应关系写入映射表（或数据库）中，以便后续的查询。

5. **重定向**：服务器将短地址发送回给客户端，客户端在接收到短地址后，会再次向服务器发送请求。

6. 客户端请求短地址：当客户端请求短地址时，将其发送到服务器。

7. 服务器处理请求：服务器收到短地址请求后，查找映射表（或数据库），找到对应的长地址。

8. **重定向**：服务器将找到的长地址发送回给客户端，客户端在接收到长地址后，会再次向服务器发送请求。

请注意，此过程中，需要确保生成的短地址是唯一的，并且要考虑到可能的并发访问和竞态条件。在实际应用中，可能还需要对长地址和短地址做一些额外的处理，比如过期时间、自定义短地址等功能。

##### 应用场景

长短地址重定向在许多应用场景中都很有用，以下是一些常见的应用场景：

1. 社交媒体分享：社交媒体平台通常会将较长的链接转换为短链接，这样更方便在限制字数的情况下分享链接。当用户点击短链接时，会被重定向到原始的长链接页面。

2. 广告和营销：在线广告和营销活动通常会使用短链接，这有助于追踪点击率和分析广告效果。同时，短链接更加美观，不会占用过多的版面。

3. URL美化：有些网站会使用短链接来美化URL，使其更易读、易记，并且减少错误输入。

4. 链接跟踪和统计：通过使用短链接，网站所有者可以更好地跟踪链接的点击量、来源和地理位置等信息，从而进行数据分析和统计。

5. **手机短信和QR码**：在手机短信或QR码中，使用短链接可以减少字符数量，使得信息更为紧凑。

6. 重定向和简化访问：网站可能会使用短链接来对用户进行重定向，尤其在处理一些复杂的URL或动态生成的URL时，短链接可以简化访问过程。

7. 防止链接过期：一些服务可能会为长期链接使用短链接，因为短链接可以被后端服务动态地更新和重定向，而无需更改用户界面或应用程序中的链接。

8. 品牌推广：短链接可以包含品牌名或关键字，帮助品牌推广和提高知名度。

总的来说，长短地址重定向在各种互联网应用中非常普遍，可以提高用户体验、简化链接、跟踪统计数据，并且有助于有效地推广和传播信息。

#### HashMap扩容为什么是两倍

在HashMap中，扩容为两倍是为了保持哈希表的**装载因子**（Load Factor）在一个较小的范围内，以提高HashMap的性能和效率。

装载因子是*HashMap中存储元素的占用程度*，它等于当前元素数量除以哈希表的大小（容量）。当装载因子达到一定阈值时，就会触发HashMap的扩容操作，将哈希表的容量扩大一倍。

假设初始HashMap的容量是N，当前存储的元素数量为M。当M/N达到设定的装载因子阈值（通常为0.75），说明哈希表已经使用了相当大比例的空间，这时为了避免哈希冲突增加，需要进行扩容操作。

扩容为两倍的主要原因是：

1. 效率和性能：扩容为两倍可以**更高效地进行哈希表的重新散列**（rehashing），即重新计算所有元素的哈希值并放入新的位置。由于哈希表容量扩大了两倍，元素在新的哈希表中的位置计算更加分散，减少了哈希冲突的可能性。

2. 减少碰撞：由于哈希表容量增加一倍，**理论上每个桶（bucket）中的元素数量也会减半**。这样，即使发生哈希碰撞（多个元素哈希值相同），在新的桶内搜索的时间复杂度也会降低，提高了HashMap的查找效率。

3. 迭代性能：在扩容过程中，由于原来的元素需要重新计算哈希值并移动到新的桶中，因此**如果扩容过程中哈希表太小，可能导致频繁的扩容操作**，影响HashMap的性能。将容量扩大为两倍可以减少扩容次数，提高迭代性能。

总的来说，将HashMap的容量扩大为两倍是一种折衷方案，在时间和空间复杂度之间寻找平衡，以提高HashMap的性能和效率。当然，也可以根据特定场景和需求进行调整装载因子的阈值，以满足不同的应用需求。