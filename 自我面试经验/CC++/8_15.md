### extern

在 C 语言中，`extern` 关键字用于声明一个变量或函数，表示该变量或函数是在其他文件中定义的。它允许在当前文件中引用其他文件中定义的全局变量或函数。`extern` 主要用于在不同的源文件之间共享变量或函数，以实现**模块化编程和代码重用。**

以下是 `extern` 关键字的一些应用场景：

1. **共享全局变量：**
   当在一个源文件中定义了全局变量，而你希望在另一个源文件中使用这个全局变量时，你可以在其他源文件中使用 `extern` 来声明该全局变量。这样，编译器会知道这个变量在其他地方被定义。

   ```c
   // 在 file1.c 中定义全局变量
   int globalVar = 10;
   
   // 在 file2.c 中使用全局变量
   extern int globalVar;
   ```

2. **引用外部函数：**
   如果你在一个源文件中定义了一个函数，并且希望在另一个源文件中调用这个函数，你可以使用 `extern` 来声明这个函数，而不是重复定义它。

   ```c
   // 在 file1.c 中定义函数
   void someFunction();
   
   // 在 file2.c 中调用函数
   extern void someFunction();
   ```

3. **多文件项目：**
   在大型项目中，通常会将不同的功能拆分到不同的源文件中，以方便管理和维护。在这种情况下，`extern` 可用于**在不同的文件之间共享变量和函数。**

4. **头文件中声明变量和函数：**
   在头文件中使用 `extern` 可以用于声明全局变量和函数的原型，这样其他源文件可以包含这个头文件，从而访问这些全局变量和函数。

   ```c
   // header.h
   extern int globalVar;
   void someFunction();
   
   // file1.c
   #include "header.h"
   int globalVar = 10;
   
   // file2.c
   #include "header.h"
   void someFunction() {
       // ...
   }
   ```

需要注意的是，`extern` 关键字只是**声明**，它不会**分配内存**或**定义变量或函数的实际内容**。实际的定义应该在其他地方进行。

在 C++ 中，由于存在链接限制和一些 C++ 特有的特性，`extern "C"` 用于在 C++ 代码中引用 C 语言的函数和变量，以确保正确的链接。

### 内联函数

在 C++ 中，内联函数是一种编译器优化技术，用于将函数的实际代码嵌入到调用处，以避免函数调用的开销。然而，并非所有函数都适合设置为内联函数。以下是一些不能设置为内联函数的情况：

1. **复杂函数体：**
   如果函数体非常复杂，包含大量的代码逻辑、分支和循环等，那么将这种函数设置为内联函数可能会导致代码膨胀，影响可读性和维护性。

2. **递归函数：**
   递归函数在每次调用时都需要保存函数的状态和上下文，内联函数要求函数的代码能够被直接嵌入到调用处，而递归函数的特性与内联优化相冲突。

3. **虚函数：**
   虚函数是用于实现多态性的，其调用需要在运行时动态绑定，而内联函数在**编译**时展开。虚函数的调用涉及虚函数表和运行时的动态分发机制，不适合内联。

4. **函数体内有循环或大量计算：**
   如果函数体内有循环或大量的计算操作，内联会导致这些代码被重复复制到每个调用处，增加了代码的大小。

5. **函数体内含有复杂的控制流：**
   包含异常处理、goto 语句、跳出循环等控制流语句的函数不适合内联，因为这些语句会增加内联代码的复杂性。

总之，内联函数适用于**简单、小巧且频繁调用的函数**，能够**减少函数调用的开销**。但对于复杂的函数，包括复杂的控制流、递归、虚函数等情况，内联可能会产生不必要的代码膨胀和性能损失，因此应该谨慎使用。编译器通常会自动决定是否将函数设置为内联，但也可以使用 `inline` 关键字进行显式的内联声明。

### char* int*的区别

`int` 类型的指针和 `char` 类型的指针是 C/C++ 中的两种不同的指针类型，它们在数据类型上有区别，以及在内存操作和指针算术上有一些不同之处。

1. **数据类型：**
   - `int` 类型的指针指向整数类型的数据。例如，`int* ptr` 可以指向一个整数变量。
   - `char` 类型的指针指向字符类型的数据。例如，`char* ptr` 可以指向一个字符变量或一个字符串。

2. **内存操作和指针算术：**
   - `int` 类型的指针在进行指针算术时，**会根据指针所指向的数据类型进行适当的偏移**。例如，`int* ptr` 增加 1 时，会使指针指向下一个 `int` 类型的位置。
   - `char` 类型的指针在进行指针算术时，会根据指针所指向的数据类型进行适当的偏移。例如，`char* ptr` 增加 1 时，会使指针指向下一个 `char` 类型的位置，而不是下一个字节。

3. **指针解引用：**
   - `int` 类型的指针解引用会得到指向的整数值。例如，如果 `int* ptr` 指向一个整数变量，`*ptr` 会获取该整数的值。
   - `char` 类型的指针解引用会得到指向的字符值。例如，如果 `char* ptr` 指向一个字符变量，`*ptr` 会获取该字符的值。如果 `char* ptr` 指向一个字符串，`*ptr` 会获取字符串的第一个字符。

4. **指针的步长：**
   - 由于 `int` 类型通常占用多个字节，`int` 类型的指针在进行指针算术时，通常会增加指向的地址值以适应整数的大小。
   - `char` 类型只占用一个字节，因此 `char` 类型的指针在进行指针算术时，每次递增一个指针单位大小（即一个字节）。

综上所述，`int` 类型的指针和 `char` 类型的指针在数据类型、指针算术、指针解引用等方面有明显的区别。选择正确的指针类型取决于你要操作的数据类型和所需的功能。

### virtual作用

在 C++ 编程中，`virtual` 关键字用于声明虚函数（virtual function）。虚函数是面向对象编程中的一个重要概念，它允许**派生类重写（覆盖）基类的函数**，实现运行时的多态性。虚函数能够在使用基类指针或引用调用时，根据对象的实际类型来确定调用的是哪个类的函数。

还有一个就是虚拟继承处理菱形继承的问题.

以下是 `virtual` 关键字的作用和用法：

1. **声明虚函数：**
   在基类中使用 `virtual` 关键字来声明虚函数。虚函数在基类中有一个对应的虚函数表中的条目。这使得派生类可以覆盖这个函数，实现自己的行为。

   ```cpp
   class Base {
   public:
       virtual void foo() {
           // 基类的虚函数实现
       }
   };
   ```

2. **派生类的函数覆盖：**
   在派生类中使用相同的函数签名（函数名和参数列表）来实现虚函数的覆盖。通过覆盖基类的虚函数，派生类可以提供自己的实现。

   ```cpp
   class Derived : public Base {
   public:
       void foo() override {
           // 派生类的虚函数实现
       }
   };
   ```

3. **运行时多态性：**
   通过使用基类指针或引用来调用虚函数，可以实现运行时的多态性。当实际对象的类型为派生类时，将调用派生类的虚函数实现。这允许程序在运行时根据对象的实际类型动态选择调用的函数。

   ```cpp
   Base* basePtr = new Derived();
   basePtr->foo();  // 调用 Derived 类的虚函数
   ```

需要注意以下几点：

- 只有类的成员函数可以声明为虚函数，而静态成员函数、构造函数不能声明为虚函数。
- 虚函数的实现必须在类的外部定义，不要在类的定义中直接提供函数体，否则可能导致链接错误。
- 基类中的虚函数可以具有默认实现，但派生类中的虚函数覆盖会取代基类的默认实现。

总之，`virtual` 关键字在 C++ 中用于实现运行时多态性，使得派生类可以覆盖基类的函数，从而实现更灵活和可扩展的代码。

### [面向接口继承IPO](https://bbs.huaweicloud.com/blogs/327026)

在设计阶段，并不会太关注内部的实现细节，而是着重于设计对象之间的协作关系，尽量达到**高内聚、低耦合**的目的。

C++中的面向接口编程，通常也被称为面向抽象编程或接口设计，是一种编程风格，通过**定义抽象的接口**（纯虚函数）来实现代码的**松耦合和模块化**。这种编程风格在很多场景下都是非常有用的，特别是在**需要实现多态性、代码重用和易于扩展的情况下。**

以下是一些适合使用面向接口编程的场景：

1. **多态性（Polymorphism）：**
   使用面向接口编程可以在基类中定义一个接口，然后在派生类中实现不同的行为。这样，可以在运行时通过基类指针或引用来调用不同派生类的方法，实现多态性，使代码更灵活和可扩展。

当谈论 C++ 中的面向接口编程时，我们通常是指通过抽象类和纯虚函数来实现的一种编程方法。下面以一个具体的场景来说明面向接口编程的应用：

假设我们正在开发一个简单的图形库，其中包含不同形状的图形（如圆形、矩形、三角形等），并且我们希望能够计算每个图形的面积。这时，面向接口编程可以帮助我们实现一个灵活和可扩展的设计。

1. **定义接口：**
   首先，我们定义一个图形的基类接口，其中包含一个纯虚函数用于计算图形的面积。这个纯虚函数表示在基类中只定义函数原型，没有实际实现。这个基类称为抽象类，因为它不具备实例化的能力。

   ```cpp
   class Shape {
   public:
       virtual double calculateArea() = 0;
   };
   ```

2. **派生具体类：**
   接下来，我们可以派生出具体的图形类，例如 Circle、Rectangle 和 Triangle。这些派生类都会实现基类中的纯虚函数，提供自己的面积计算方法。

   ```cpp
   class Circle : public Shape {
   private:
       double radius;
   
   public:
       Circle(double r) : radius(r) {}
   
       double calculateArea() override {
           return 3.14159 * radius * radius;
       }
   };
   ```

3. **多态性应用：**
   使用面向接口编程，我们可以在主程序中以抽象类的指针形式存储不同的图形对象，然后通过多态性调用每个图形的面积计算方法，而无需关心具体是哪个派生类。

   ```cpp
   int main() {
       Shape* shapePtr;
       Circle circle(5.0);
       Rectangle rectangle(4.0, 6.0);
       Triangle triangle(3.0, 4.0);
   
       shapePtr = &circle;
       cout << "Circle Area: " << shapePtr->calculateArea() << endl;
   
       shapePtr = &rectangle;
       cout << "Rectangle Area: " << shapePtr->calculateArea() << endl;
   
       shapePtr = &triangle;
       cout << "Triangle Area: " << shapePtr->calculateArea() << endl;
   
       return 0;
   }
   ```

通过面向接口编程，我们实现了多态性，使得我们可以轻松地添加新的图形类型，而不需要修改主程序。这种灵活性和可扩展性是面向接口编程的主要优势之一。通过定义抽象接口并在派生类中实现具体行为，我们可以实现更加松耦合和模块化的设计。总之，面向接口编程在需要实现**松耦合、多态性**、代码扩展性和模块化的情况下非常有用。通过定义抽象的接口，可以使得代码更加灵活，更易于维护和扩展。

### [函数栈帧](https://blog.csdn.net/weixin_58843717/article/details/130682155?spm=1001.2014.3001.5501)

> 1. eax : 通用寄存器,保留临时数据,常用于返回值的暂时保存
> 2. esp: top of stack,栈顶寄存器,指向函数栈帧的栈顶
> 3. ebp: 指向栈底
> 4. eip: 指令寄存器,保存当前指令的下一条指令
>
> - mov: 数据转移指令
> - call : 压栈返回函数地址, 转入目标函数
> - ret: 恢复返回地址,压入eip 
