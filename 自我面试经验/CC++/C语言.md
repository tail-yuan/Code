#### 二进制偶校验位

如果要将69的二进制表示中的最高位设置为偶校验位，首先需要确定校验位的值，以使得整个二进制数中1的个数（包括校验位在内）为偶数。在这种情况下，69的二进制表示是1000101，其中有3个1。

要使总共有偶数个1，需要将校验位设置为1。所以，最高位设置为偶校验位后的二进制表示为1100101。现在，这个二进制数中有4个1，总数是偶数，满足偶校验的条件。

#### 预处理运算符(笔试选择题)

##### ##

将左侧符号和右侧符号链接起来构成一个新符号

##### #

- 将参数符号s对应的文本内容转化为字符串.
- 相邻字符串(“”)具有自动连接特性.

```C++
#define PRINT(A) printf("%s", #A)
#define COMBINE(A, B) A##B

int main() {
    char abs[] = "abcd";
    PRINT(COMBINE(abs, __LINE__));//COMBINE(abs, __LINE__)
    return 0;
}
```



### feof fgets fgetc

`feof`, `fgets`, 和 `fgetc` 是用于处理文件输入和判断文件结束的C标准库函数。下面我将解释它们的用法：

1. `feof` 函数：
   - `feof` 函数用于检查文件是否已经**到达了文件的结束位置**。
   - 使用方法：通常，你会在读取文件时使用 `feof` 来检查文件是否已经结束。它不会主动读取文件，而只会告诉你文件是否已经结束。
   - 示例：
     ```c
     FILE *file = fopen("example.txt", "r");
     if (file == NULL) {
         perror("Unable to open file");
         return 1;
     }
     
     while (!feof(file)) {
         char c = fgetc(file);
         if (!feof(file)) {
             // 处理文件内容
             putchar(c);
         }
     }
     
     fclose(file);
     ```

2. `fgets` 函数：
   - `fgets` 用于从文件中读取一行文本数据。
   - 使用方法：你可以使用 `fgets` 来读取文件中的一行文本数据，并将其存储在一**个字符数组**中。
   - 示例：
     ```c
     FILE *file = fopen("example.txt", "r");
     if (file == NULL) {
         perror("Unable to open file");
         return 1;
     }
     
     char buffer[100]; // 用于存储读取的行
     while (fgets(buffer, sizeof(buffer), file) != NULL) {
         // 处理读取的行
         printf("%s", buffer);
     }
     
     fclose(file);
     ```

3. `fgetc` 函数：
   - `fgetc` 用于从文件中逐个字符读取数据。
   - 使用方法：你可以使用 `fgetc` 逐个字符地读取文件中的数据。
   - 示例：
     ```c
     FILE *file = fopen("example.txt", "r");
     if (file == NULL) {
         perror("Unable to open file");
         return 1;
     }
     
     int c; // 用于存储读取的字符
     while ((c = fgetc(file)) != EOF) {
         // 处理读取的字符
         putchar(c);
     }
     
     fclose(file);
     ```

注意事项：
- 总是在使用这些函数之前检查文件是否成功打开（例如，通过检查文件指针是否为NULL）。
- 使用 `fclose` 函数来关闭文件，以释放资源并确保数据已经写入或读取完成。

### 打开文件

在C语言中，你可以使用以下函数以二进制方式打开一个文件：

1. `fopen` 函数：
   ```c
   FILE *fopen(const char *filename, const char *mode);
   ```
   你可以将 `mode` 参数设置为 `"rb"`，表示以只读二进制方式打开文件。例如：
   ```c
   FILE *file = fopen("example.bin", "rb");
   ```

2. `freopen` 函数：
  
   ```c
   FILE *freopen(const char *filename, const char *mode, FILE *stream);
   ```
   同样，你可以将 `mode` 参数设置为 `"rb"`，以只读二进制方式重新打开一个文件，例如：
   ```c
   FILE *file = freopen("example.bin", "rb", file);
   ```

这两个函数都允许你以二进制方式打开文件，其中 `"b"` 表示以二进制方式打开文件。这通常用于处理二进制文件，如图像、音频或其他非文本文件。要注意，在不同的操作系统上，可能会有一些差异，例如在Windows上，以二进制方式打开文件可能会有不同的行为，因此请根据你的需要和目标平台来选择适当的函数。

### 链接

如果两个不同的动态库（Shared Libraries）包含同名的全局函数，并且一个程序试图链接这两个库，结果将取决于链接器和运行时加载器如何处理这种冲突。一般来说，有以下几种可能的情况：

1. **延迟绑定（Lazy Binding）**：在运行时，当函数第一次被调用时，动态链接器会解析该函数的地址。如果两个库包含同名函数，通常只有其中一个会被调用，具体哪一个取决于链接顺序和操作系统的动态链接器如何处理这种冲突。

2. **符号解析策略**：某些系统允许你指定哪个库中的符号（在这里，指函数名）应该被优先考虑。这通常是通过一些特殊的编译器或链接器选项来完成的。

3. **命名空间或版本控制**：一些现代的链接器和动态库支持命名空间或API版本控制，以减少这种冲突的可能性。

4. **静态链接**：如果两个冲突的函数是静态链接到程序中的，那么链接器通常会在链接时报告错误。

5. **dlsym 和 dlopen**：在Unix和Linux系统中，你可以使用 `dlopen()` 和 `dlsym()` 函数显式地打开动态库并获取函数的地址。这样，你可以更明确地控制哪个库的哪个函数被调用。

6. **弱符号和强符号**：在某些情况下，你可以通过将其中一个函数声明为“弱符号”（Weak Symbol）来解决冲突。当有多个同名符号存在时，弱符号会被强符号（Strong Symbol）覆盖。

因此，从技术上说，两个包含同名全局函数的动态库**可能不能简单地被同时链接**，除非你采取一些**特殊措施来解决或避免这种符号冲突**。如果可能，最好的办法是避免使用同名的全局函数，或者使用命名空间、类或其他方法来避免命名冲突。

### main

```C
int main()
{
	
	printf("%p", main);//正常打印地址,并不会死循环,只是在main外看一眼地址,又没调用,肯定不会出现层层嵌套死循环的问题
	return 0;
}

```



### fopen函数

在 C 语言中，`fopen` 函数用于打开文件，并返回一个与该文件关联的文件指针。这个函数通常用于创建新文件或打开现有文件，以进行读取、写入或其他操作。

下面是 `fopen` 的基础语法：

```c
FILE *fopen(const char *path, const char *mode);
```

- `path`: 要打开或创建的文件的路径。
- `mode`: 文件打开模式，它决定了文件如何被打开（读取、写入等）。

返回值是一个 `FILE` 指针，用于后续的文件操作（如 `fread`, `fwrite`, `fclose` 等）。如果打开文件失败，它将返回 `NULL`。

#### 文件打开模式

以下是一些常用的文件打开模式：

1. **`"r"`**: 打开一个已存在的文件用于读取。
2. **`"w"`**: 创建一个新文件用于写入。如果文件已存在，其内容将被清空。
3. **`"a"`**: 打开一个已存在的文件用于追加（在文件末尾写入）。如果文件不存在，会创建一个新文件用于写入。
4. **`"r+"`**: 打开一个已存在的文件用于读取和写入。
5. **`"w+"`**: 创建一个新文件用于读取和写入。如果文件已存在，其内容将被清空。
6. **`"a+"`**: 打开一个已存在的文件用于读取和追加。如果文件不存在，会创建一个新文件用于读取和写入。

这些模式还可以与二进制模式结合使用：

- **`"rb"`, `"wb"`, `"ab"`, `"r+b"`, `"w+b"`, `"a+b"`**: 在模式字符串中添加 `b`（例如 `"rb"` 或 `"w+b"`）将文件视为二进制文件，这样，数据将以字节为单位进行读取和写入，而不会执行任何字符转换。

### 示例

下面是使用 `fopen` 的一个简单示例：

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("example.txt", "r");
    if (file == NULL) {
        printf("Failed to open file.\n");
        return 1;
    }
    // 后续的文件操作
    fclose(file);
    return 0;
}
```

注意：使用 `fopen` 打开文件后，记得在完成所有文件操作后调用 `fclose` 函数关闭该文件.

### 转移字符\

```C
void test3()
{
	int id1 = strlen("\ta\045pq");//5    \045被当成同一个字符了,并不会出现\0中止的现象
	int id2 = sizeof("\ta\045pq");//6
    int id = strlen("\ta\0pq");//2
	printf("%d ", id1);
	printf("%d ", id2);
}
```

### 函数指针声明

这个 C 语言的类型声明有点复杂，但让我们一步步解构它。

```c
double (*(*(*fp)(int))[5])(char);
```

在这里，`fp` 是一个指针，指向一个函数。这个函数接受一个 `int` 类型的参数，并返回一个指针。这个返回的**指针指向一个拥有 5 个元素的数组**，而数组的每个元素都是**指向函数的指针**。这些函数接受一个 `char` 类型的参数，并返回一个 `double` 类型的值。

换句话说：

- `fp` 是一个指针，指向一个函数（接受一个 `int` 参数并返回一个指针）。
- 这个返回的指针，指向一个有 5 个元素的数组。
- 数组里的每个元素都是一个指针，指向一个函数（这个函数接受一个 `char` 参数并返回一个 `double`）。

这样的类型声明在实际编程中是比较罕见的，但理解这样的声明有助于深入了解 C 语言的类型系统。如果你有更多关于这个类型或其他复杂类型的问题，随时提问！

### 哈夫曼树

在哈夫曼编码中，带权路径长度（Weighted Path Length）是用于评估编码效率的一种指标。假设我们有一组带权重的字符（或其他类型的数据项），带权路径长度就是所有字符（叶节点）的权重与其到根节点路径长度的乘积之和。

如果你提供的数字 "1 3 6 8" 是各叶子节点的权重，构建一个哈夫曼树的步骤一般如下：

1. 将所有节点按权重排序：1, 3, 6, 8。
2. 取出两个最小的节点，并创建一个新的内部节点，其权重是这两个节点权重的和。在这里，1 + 3 = 4。
3. 将新创建的内部节点重新插入到队列，并重新排序。新的序列：4, 6, 8。
4. 重复上述步骤，直到只剩下一个节点，这个节点就是哈夫曼树的根节点。

构建过程：

- 1 + 3 = 4 （叶节点深度：1，带权路径长度：`1*1 + 3*1 = 4）`
- 4 + 6 = 10（叶节点深度：2，带权路径长度：`4*2 + 6*2 = 20）`
- 10 + 8 = 18（叶节点深度：3，带权路径长度：`10*3 + 8*3 = 54）`

最终，哈夫曼树的带权路径长度是 4（来自第一层）+ 20（来自第二层）+ 54（来自第三层）= 78。

请注意，这是一个特定的构建哈夫曼树和计算带权路径长度的例子。实际的情况可能会因为构建哈夫曼树的具体方式（比如选择哪两个节点进行合并）而有所不同。