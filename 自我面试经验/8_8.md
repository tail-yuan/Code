#### pthread库和C++中std::thread区别

C语言的pthread库和C++的std::thread库都用于创建和管理多线程，但它们在底层实现上存在一些区别，主要是因为C++的std::thread库更加面向对象和与C++语言特性更紧密相关。以下是它们之间的一些主要区别：

1. **面向对象 vs. 过程式：**
   - C语言是过程式编程语言，pthread库的设计也更倾向于过程式风格。它提供了一组函数来创建、管理和同步线程，通常需要使用函数指针等来实现线程函数。
   
   - C++是面向对象编程语言，std::thread库的设计更加面向对象，它将线程的创建和管理封装在对象中，允许线程函数作为可调用对象传递，使得线程的使用更加直观。

2. **函数签名和传递参数：**
   - 在pthread库中，线程函数需要具有特定的签名，即返回类型为`void*`，接受一个`void*`类型的参数。通常，你需要将参数通过指针传递。

   - 在std::thread库中，你可以传递**任何可调用对象**作为线程函数，包括函数指针、函数对象（functors）和Lambda表达式。参数传递更加灵活，可以直接传递参数，而不需要使用指针。

3. **异常处理：**
   - C++的std::thread库能够更好地与C++异常机制交互。如果在线程函数中抛出异常，异常会被传递到创建线程的上下文中，允许你在主线程中捕获和处理异常。

   - 在pthread库中，异常的处理相对复杂，通常需要在线程函数内部捕获异常并处理。

4. **资源管理：**
   - C++的std::thread库提供了RAII（Resource Acquisition Is Initialization）机制，可以更容易地管理线程资源。线程对象在离开作用域时会自动销毁，确保线程资源的正确释放。

   - pthread库需要手动调用函数来销毁线程，并确保资源的释放。

5. **编译依赖：**
   - C++的std::thread库是C++标准库的一部分，因此在支持C++11及更高版本的编译器中都可以使用。

   - pthread库是Linux系统下的一个库，需要在编译时链接`-lpthread`库，而且在不同系统和平台上的实现可能略有不同。

总的来说，C++的std::thread库提供了更现代和面向对象的方式来创建和管理多线程，而pthread库则是一个更底层的多线程库，适用于C语言和一些对线程控制有更高要求的情况。

#### C++解析http请求

![image-20230808191023892](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230808191023892.png)

在C++中解析HTTP请求可以通过以下步骤实现。HTTP请求通常遵循HTTP协议规范，其中包含请求行、请求头部和请求主体等部分。以下是一个基本的HTTP请求解析示例，假设请求格式是标准的：

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <sstream>

struct HttpRequest {
    std::string method;
    std::string path;
    std::string version;
    std::vector<std::string> headers;
    std::string body;
};

// 解析HTTP请求
HttpRequest parseHttpRequest(const std::string& requestStr) {
    HttpRequest request;

    std::istringstream requestStream(requestStr);
    
    // 解析请求行
    requestStream >> request.method >> request.path >> request.version;
    
    // 解析请求头部
    std::string header;
    while (std::getline(requestStream, header) && header != "\r") {
        request.headers.push_back(header);
    }
    
    // 解析请求主体
    std::getline(requestStream, request.body);
    
    return request;
}

int main() {
    // 示例HTTP请求字符串
    std::string httpRequestString = "GET /index.html HTTP/1.1\r\n"
                                    "Host: example.com\r\n"
                                    "User-Agent: Mozilla/5.0\r\n"
                                    "\r\n"
                                    "Request body content";
    
    HttpRequest request = parseHttpRequest(httpRequestString);
    
    std::cout << "Method: " << request.method << std::endl;
    std::cout << "Path: " << request.path << std::endl;
    std::cout << "Version: " << request.version << std::endl;
    
    std::cout << "Headers:" << std::endl;
    for (const std::string& header : request.headers) {
        std::cout << header << std::endl;
    }
    
    std::cout << "Body: " << request.body << std::endl;
    
    return 0;
}
```

在这个示例中，`parseHttpRequest` 函数将一个HTTP请求字符串作为输入，然后解析其中的请求行、请求头部和请求主体。最后，将解析得到的信息存储在 `HttpRequest` 结构体中，以供后续使用。请注意，这只是一个简化的示例，实际上，HTTP请求可能更复杂，包含更多的信息和选项。因此，在实际应用中，你可能需要更复杂的解析逻辑来处理各种情况。

#### 程序运行全过程

理解一个程序在Linux操作系统中的运行过程涉及多个步骤，从程序的编译、加载、执行，到最终的终止。下面是一个典型的程序在Linux中运行的全过程：

1. **编写源代码：** 首先，程序员使用文本编辑器编写源代码，使用编程语言如C++，Python等。

2. **编译源代码：** 源代码需要被编译成机器可执行的二进制文件。在Linux中，使用编译器如`g++`（C++）、`gcc`（C）或`python`（Python）等将源代码编译成可执行文件。编译过程将源代码翻译成计算机能够理解的机器码。

3. **生成可执行文件：** 编译器将生成一个可执行文件，这个文件包含了机器码和程序的其他元数据。

4. **加载到内存：** 当你运行可执行文件时，操作系统将加载这个文件到内存中。操作系统会为程序分配一块内存空间，其中包含代码段、数据段、堆和栈等.先描述在组织的方式生成进程控制块PCB.

5. **执行程序：** 一旦程序被加载到内存，操作系统会将程序的控制权交给它。程序的代码段开始执行，从`main`函数（或其他入口函数）开始执行。

6. **程序运行：** 程序开始按照代码逻辑执行，可能会涉及用户输入、计算、文件操作等。

7. **系统调用：** 在程序运行过程中，如果需要进行系统级的操作，比如文件读写、网络通信等，程序会通过系统调用向操作系统发起请求，操作系统会代表程序执行所需的任务。

8. **上下文切换：** 在多任务操作系统中**，CPU会在不同进程之间切换执行**。这个过程叫做上下文切换。操作系统会保存当前进程的状态，然后切换到下一个进程。上下文切换会发生在多个进程之间，也可能发生在同一进程的不同线程之间。

9. **终止程序：** 程序的执行可能会通过返回主函数（或其他退出点）或调用`exit`函数来终止。在终止之前，程序可以释放资源、关闭文件等。

10. **释放内存和资源：** 当程序终止时，操作系统会释放为程序分配的内存和其他资源，以便其他进程使用。

11. **程序终止：** 最终，程序会终止，其在内存中的内容会被清理。

需要注意的是，Linux操作系统本身会对程序的执行进行管理和调度，以便合理地分配系统资源，保证系统的稳定性和性能。整个过程涉及多个系统组件和机制的协作，以确保程序能够在操作系统环境中运行并实现预期的功能。

#### 分页分段段页式

1. **分页（Paging）：** 分页是一种内存管理技术，将物理内存和虚拟内存划分为固定大小的页。虚拟地址空间被分成大小相同的页，物理内存也被分成相同大小的物理页帧。操作系统使用页表将虚拟地址映射到物理地址，从而实现虚拟内存到物理内存的映射。分页机制可以减少外部碎片，但可能引入内部碎片。

2. **分段（Segmentation）：** 分段是一种内存管理技术，将虚拟地址空间划分为不同的段，每个段对应着一个逻辑单元，如代码段、数据段等。每个段的大小可以不同。分段可以更好地支持不同大小的程序模块，但可能引入外部碎片。

3. **段页式（Paged Segmentation）：** 段页式是将分段和分页两种技术结合起来的内存管理方法。在这种方法中，虚拟地址空间首先被划分为多个段，每个段再被分成大小相同的页。这种方式既能够提供段的灵活性，又能够通过分页机制来优化内存的管理和映射。

总的来说，分页、分段和段页式是操作系统中常用的内存管理技术，它们在不同情况下具有不同的优势和适用性。选择何种内存管理方式取决于应用的需求、系统设计以及性能要求。在实际应用中，操作系统可能会综合考虑这些技术，选择最适合的内存管理策略。

#### 操作系统如何管理内存

操作系统通过内存管理来有效地分配、跟踪和保护计算机系统中的内存资源。内存管理在操作系统中的主要任务包括内存分配、内存保护、虚拟内存管理等。

以下是操作系统管理内存的一些关键方面：

Linux操作系统采用多种方式来管理内存，以确保高效地分配、保护和利用内存资源。以下是Linux中常用的一些内存管理方式：

1. **页表和分页机制：** Linux使用分页机制将虚拟内存地址空间划分为固定大小的页，通常是4KB。页表用于映射虚拟地址到物理地址，以实现虚拟内存到物理内存的映射。
2. **虚拟内存和交换空间：** Linux支持虚拟内存技术，允许进程访问比物理内存更大的地址空间。当物理内存不足时，Linux可以将部分不活跃的数据和代码交换到磁盘上的交换空间（swap space）中，以释放物理内存供活跃进程使用。
3. **OOM（Out-of-Memory）处理：** 当系统内存不足以支持运行的进程时，Linux的OOM处理机制会尝试终止某些进程，以释放内存。这有助于保持系统的稳定性，避免系统崩溃。
4. **内存清理和整理：** Linux的内存管理机制会周期性地进行内存清理和整理，以合并碎片化的内存块，从而提供更大的可用内存空间。
5. **内存保护和隔离：** Linux使用地址空间隔离和用户态/内核态分离等机制，保护不同进程的内存空间，防止进程之间的干扰和冲突。
9. **内存统计和监控：** Linux提供了工具和接口，如`top`、`free`、`vmstat`等，用于监控系统内存使用情况，并分析内存性能问题.

1. **内存分配：** 操作系统负责将物理内存划分为多个区域，以便为不同的进程和任务分配内存空间。内存分配的方式可以是连续的，也可以是离散的。在连续内存分配中，操作系统会分配一块连续的物理内存给进程，而在离散内存分配中，内存被划分为多个小块，可以分配给多个进程，更灵活。
2. **内存回收：** **当进程终止或释放内存时**，操作系统需要回收这些内存，以便将其重新分配给其他进程。内存回收可以通过垃圾收集机制（在一些高级编程语言中）或者手动释放内存来实现。
3. **内存清理和整理：** 在运行过程中，内存中可能会产生碎片，即分散的未被使用的小块内存。操作系统可能需要进行内存清理和整理，以便合并碎片化的内存空间，从而提供更大的可用内存块。

#### get 和post的区别

"GET"和"POST"是HTTP协议中常用的两种请求方法，用于从客户端向服务器发送数据。它们在如何传递数据以及适用场景上有一些区别。

1. **数据传递方式：**
   - **GET：** 在GET请求中，数据是**通过URL**的查询参数（query parameters）传递的，将数据附加在URL的末尾，以`?`分隔参数，参数之间用`&`连接。例如：`http://example.com/page?name=John&age=25`。由于数据是附加在URL中，GET请求的数据传递是可见的，可以在浏览器地址栏中看到。
   
   - **POST：** 在POST请求中，数据通过请求的消息体传递，不会在URL中显示。这意味着数据不会在浏览器的地址栏中暴露，因此更适合传递敏感信息。

2. **数据传输大小：**
   - 由于GET请求的数据是附加在URL中的，所以传输的数据量有限。不同的浏览器和服务器对URL的最大长度有不同的限制，但通常较小，大约在2048个字符左右。
   
   - POST请求的数据传输大小没有这个限制，因为数据是通过请求的消息体传递的，可以传输较大的数据量。

3. **安全性：**
   - GET请求的数据是可见的，因此不适合传递敏感信息，如密码等。因为数据出现在URL中，可**能被保存在浏览器的历史记录、服务器的日志文件或代理服务器的缓存中。**

   - POST请求的数据是在请求消息体中传递的，不会在URL中显示，因此更适合传递敏感信息。

4. **缓存：**
   - GET请求可以被浏览器缓存，因为数据是直接附加在URL中的，可以被认为是**无副作用的请求**。这使得再次发送相同的GET请求时，**浏览器可能会从缓存中获取响应**，而不是向服务器发起请求。

   - POST请求默认情况下**不会被浏览器缓存**，因为POST请求可能**对服务器产生影响**，例如提交表单数据等。

总结来说，GET和POST请求适用于不同的场景。GET适合获取数据，传递少量数据，而POST适合传递大量数据、传递敏感信息或者在服务器上执行一些操作（例如提交表单数据）。在选择使用哪种方法时，应根据具体的需求和安全性考虑来决定。

#### 同步IO和异步IO

同步I/O（Input/Output）和异步I/O是关于如何进行数据的输入和输出操作的两种不同的编程模式。它们的区别主要在于操作的执行方式和程序的控制流。

1. **同步I/O（Synchronous I/O）**：
同步I/O是指在进行I/O操作时，**程序会阻塞等待操作完成**。在进行读取或写入数据时，程序会停止执行直到操作完成，然后再继续执行后续的代码。同步I/O的特点是简单易用，代码顺序清晰，但当操作较慢或阻塞时，会造成程序的停顿，影响系统的响应性。

2. **异步I/O（Asynchronous I/O）**：
异步I/O是指在进行I/O操作时，**程序可以继续执行其他任务，而不会等待操作完成**。在异步I/O模式下，可以提交一个操作请求，然后继续执行其他任务，当操作完成时，系统会通知程序，程序再去处理已完成的操作。异步I/O的优点是可以提高程序的并发性和响应性，但相对复杂一些，需要更多的编程技巧。

总结：
- 同步I/O在操作完成前会阻塞程序的执行，适用于简单场景。
- 异步I/O允许程序在等待I/O操作完成时继续执行其他任务，适用于提高并发性和响应性要求较高的场景。

#### recv如何设置同步异步

在C/C++中，`recv` 函数通常用于从套接字（socket）接收数据。`recv` 函数本身是一个同步阻塞函数，它会一直等待直到有数据到达或发生错误。但是，你可以通过设置套接字的属性来实现异步操作。以下是使用不同方式设置同步和异步 `recv` 的方法：

1. **同步方式**：
默认情况下，`recv` 函数是同步的，它会一直等待直到有数据到达或发生错误。示例代码如下：

```cpp
#include <iostream>
#include <sys/socket.h>
#include <unistd.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    // 设置套接字参数，如绑定地址和端口等
    
    char buffer[1024];
    ssize_t bytesReceived = recv(sockfd, buffer, sizeof(buffer), 0);
    
    if (bytesReceived > 0) {
        // 处理接收到的数据
    } else if (bytesReceived == 0) {
        // 连接关闭
    } else {
        // 接收错误
    }
    
    close(sockfd);
    return 0;
}
```

2. **异步方式**：
要实现异步操作，你需要使用操作系统提供的异步I/O机制，如**使用非阻塞套接字**、多线程、多进程或异步I/O库（如Boost Asio、libuv等）。以下是使用非阻塞套接字的示例：

```cpp
#include <iostream>
#include <sys/socket.h>
#include <fcntl.h>  // for fcntl

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    // 设置套接字参数，如绑定地址和端口等
    
    // 设置非阻塞模式
    int flags = fcntl(sockfd, F_GETFL, 0);
    fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
    
    char buffer[1024];
    ssize_t bytesReceived = recv(sockfd, buffer, sizeof(buffer), 0);
    
    if (bytesReceived > 0) {
        // 处理接收到的数据
    } else if (bytesReceived == 0) {
        // 连接关闭
    } else {
        // 没有数据可读或出现错误
    }
    
    // 进行其他任务
    
    close(sockfd);
    return 0;
}
```

在实际的异步I/O编程中，可能需要考虑更复杂的情况，如事件循环、回调函数等。使用异步操作时，请确保你了解操作系统和编程库提供的异步机制以及如何使用它们。

#### 查看进程打开了那些文件

在Linux系统中，你可以使用 `lsof` 命令（"list open files"）来查看一个进程打开了哪些文件。这个命令可以显示进程打开的文件、网络连接、目录等信息。以下是使用 `lsof` 命令的基本用法：

```
lsof -p <进程ID>
```

将 `<进程ID>` 替换为你要查看的进程的实际ID。这将列出该进程打开的所有文件、目录和网络连接信息。

例如，假设你要查看进程ID为 12345 的进程打开了哪些文件：

```
lsof -p 12345
```

如果你想查看所有正在运行的进程打开的文件，可以省略 `-p` 参数：

```
lsof
```

这将列出系统上所有进程打开的文件。

`lsof` 命令还支持许多选项和参数，以便更详细地探查打开的文件和连接。你可以查阅 `lsof` 的手册页面（`man lsof`）或者在终端中运行 `lsof --help` 以获取更多信息和使用方法。

#### 数据库三种范式

数据库范式是一种设计原则，用于规范化关系型数据库的结构，以避免数据冗余和提高数据存储效率。目前共有三种主要的范式，分别是第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。以下是对每种范式的简要介绍：

1. **第一范式（1NF）**：
  必须要设定主键,并且第一范式要求数据库中的每个属性（列）都只能包含不可再分的**原子值**，即不再具有嵌套的结构。

  比如一个属性列是任务联系方式就不行,联系方式可以有邮箱,电话合在一起不构成原子值.

2. **第二范式（2NF）**：
  第二范式在满足第一范式的基础上，进一步要求在关系中的每个非主键属性都完全依赖于主键，而不是依赖于主键的一部分。简而言之，如果主键是由多个属性组成的，那么非主键属性必须直接依赖于**所有主键属性**，而**不是仅依赖于部分主键属性**。

  比如设定主键是复合主键包含多个元素,这时某个属性列只部分依赖于复合主键中的一个,这时不满足第二范式.

  抛弃复合主键,多创建一张表.

3. **第三范式（3NF）**：
  第三范式在满足第二范式的基础上，进一步要求在关系中的每个**非主键属性**都不依赖于**其他非主键属性**。这意味着每个非主键属性都应该只与主键属性直接相关，而不是与其他非主键属性相关。这有助于消除传递依赖，减少数据冗余。

  比如学生学号做主键,班级号为非主键属性,班级名也不分依赖于这个班级号,就违反第三范式.

  可以多创建一张表,<班级号,班级名,学生号>设计外键.


需要注意的是，范式化数据库设计可以提高数据的一致性和规范性，但有时可能会导致查询的复杂性增加。在实际设计中，根据具体情况，可以根据性能需求、数据复杂性等因素来平衡是否采用范式化设计。有时，可能会根据实际情况放宽范式要求，以达到更好的查询性能。

#### multimap

在C++中，`std::multimap` 是一个关联容器，允许存储多个相同关键字的元素，并且会根据关键字的顺序进行排序。`std::multimap` 并不直接区分两个相同关键字的元素，而是依靠元素的排序来进行区分。这意味着如果你插入了两个相同关键字的元素，它们**会按照特定的排序规则排列在容器中**。

以下是一个示例，展示了如何使用 `std::multimap` 并观察它是如何处理相同关键字的情况：

```cpp
#include <iostream>
#include <map>

int main() {
    std::multimap<int, std::string> myMultimap;

    // 插入元素
    myMultimap.insert(std::make_pair(1, "one"));
    myMultimap.insert(std::make_pair(2, "two"));
    myMultimap.insert(std::make_pair(1, "uno"));  // 插入相同关键字的元素
    myMultimap.insert(std::make_pair(3, "three"));
    myMultimap.insert(std::make_pair(2, "dos"));  // 插入相同关键字的元素

    // 遍历输出
    for (const auto& pair : myMultimap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

在上面的示例中，当插入相同关键字的元素时，它们会根据关键字的排序规则进行插入，并且会保持排序顺序。输出结果可能是：

```
1: one
1: uno
2: two
2: dos
3: three
```

正如你可以看到的，`std::multimap` 并没有显式区分相同关键字的元素，而是依靠排序规则来保持它们在适当的位置。如果你想要在处理相同关键字时有更精细的控制，你可能需要结合使用 `std::multimap` 和其他数据结构，或者自定义排序规则。

#### OSI七层和TCP/IP四层的区别

OSI（Open Systems Interconnection）和TCP/IP（Transmission Control Protocol/Internet Protocol）都是用于描述计算机网络体系结构的模型，但它们的层级结构和关注重点略有不同。

OSI七层模型：

1. 物理层（Physical Layer）：处理物理媒介传输，例如电压、电流、光信号等。主要关注数据传输的物理特性。

2. 数据链路层（Data Link Layer）：在相邻节点之间传输数据帧，提供了错误检测和纠正功能。以太网协议位于此层。

3. 网络层（Network Layer）：处理数据包的路由和转发，实现不同网络之间的通信。IP协议位于此层。

4. 传输层（Transport Layer）：提供端到端的可靠数据传输，负责分段、流量控制、错误检测和恢复。TCP和UDP协议位于此层。

5. 会话层（Session Layer）：管理应用程序之间的会话，并处理会话的建立、维护和终止。

6. 表示层（Presentation Layer）：处理数据的**格式转换、加密解密**等，确保不同系统间的数据格式兼容性。

7. 应用层（Application Layer）：提供网络服务给最终用户，例如HTTP、SMTP、FTP等协议都在此层实现。

TCP/IP四层模型：

1. 数据链路层（Network Interface Layer）：类似于OSI的物理层和数据链路层，处理物理媒介和帧的传输。

2. 网际层（Internet Layer）：类似于OSI的网络层，处理数据包的路由和转发。IP协议位于此层。

3. 传输层（Transport Layer）：与OSI的传输层类似，提供端到端的可靠数据传输。TCP和UDP协议位于此层。

4. 应用层（Application Layer）：与OSI的应用层类似，提供网络服务给最终用户。HTTP、SMTP、FTP等协议都在此层实现。

主要区别：

1. 层数：OSI模型有七层，而TCP/IP模型只有四层，其中一些功能在TCP/IP中被合并在一起。

2. 细节程度：OSI模型更详细，每一层都具有更多的子层和功能。TCP/IP模型则较为简化，更加实际。

3. 发展历史：OSI模型是国际标准化组织（ISO）提出的，而TCP/IP模型是实际互联网的发展过程中逐渐形成的。

4. 使用范围：TCP/IP模型更广泛地用于描述实际互联网的架构，而OSI模型更多地被用于学术和标准化领域。

总的来说，尽管这两个模型都描述了计算机网络的层级结构，但TCP/IP模型更贴近实际互联网的实现，而OSI模型则更多地被用于教学和理论研究。