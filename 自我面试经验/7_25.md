#### C/C++的区别

1. C是面向过程的,C++是面向对象的编程语言.

   指出C是一种面向过程的编程语言，主要关注函数的设计和功能的实现，

   而C++是一种面向对象的编程语言，除了支持C的所有特性外，还增加了类、对象、继承、封装、多态等**面向对象编程的概念**.

2. C++相比于C具有更丰富的**编程范式**。

   1. 模板
   2. 重载
   3. 多态

3. 封装和权限设置(struct-class)

强调C++中的类提供了访问控制机制，可以使用`public`、`private`和`protected`关键字来限制成员的访问权限，从而实现数据封装。指出C语言没有直接支持这种访问控制。

4. C++中的异常处理等其他特性，指出这些特性在C语言中是缺失的。

5. 引入STL库中的数据结构,使用更加方便.

#### 数组和链表的区别

在C++开发面试中，清晰地解答数组和链表的区别是非常重要的，因为它们是两种常见的数据结构，面试官通常会询问有关它们的问题。以下是你可以使用的方法来调理清晰地回答这个问题：

1. **定义和结构：**
   - 数组是一种固定大小、连续存储的数据结构，其中元素通过索引进行访问。数组在内存中的布局是连续的，每个元素都有一个唯一的索引，从0开始递增。
   - 链表是一种动态数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针（单链表）或同时包含指向前一个节点的指针（双向链表）。

2. **内存分配：**
   - 数组在创建时需要预先分配**固定大小的内存空间**，其大小在编译时就确定了。这意味着数组的大小不能动态调整，除非重新创建一个新的数组并复制数据。
   - 链表的节点在运行时动态创建，每个节点可以在不同的内存位置，因此可以在运行时灵活地添加或删除节点。

3. **插入和删除操作：**
   - 数组的插入和删除操作通常较慢，特别是在数组中间或开头插入/删除元素，因为需要移动其他元素以保持连续性。
   - 链表的插入和删除操作相对较快，只需要调整节点的指针来改变连接关系，不需要移动其他节点。

4. **访问效率：**
   - 数组具有良好的随机访问性能，通过索引可以在O(1)时间内直接访问任意元素。
   - 链表的随机访问性能较差，需要遍历链表才能找到特定位置的元素，平均时间复杂度为O(n)。

5. **空间复杂度：**
   - 数组的空间复杂度固定，取决于数组的大小。
   - 链表的空间复杂度较高，因为每个节点除了存储数据外，还需要存储一个指向下一个（和前一个，如果是双向链表）节点的指针。

6. **适用场景：**
   - 数组适用于已知大小且需要频繁随机访问的情况，例如需要通过索引快速访问元素的情况。
   - 链表适用于需要频繁插入和删除元素的情况，因为它们的插入和删除操作效率较高。

#### 进程和线程的区别

进程和线程都是计算机操作系统中的重要概念，它们代表了并发执行的基本单位。它们之间的主要区别如下：

1. **定义：**
   - 进程（Process）：进程是计算机中正在运行的程序的实例。每个进程都有自己独立的地址空间，包括代码、数据、打开的文件、系统资源等。进程之间相互独立，一个进程的崩溃不会影响其他进程。
   - 线程（Thread）：线程是进程中的一个执行单元，每个进程可以有多个线程**共享相同的地址空间**。线程之间可以方便地共享数据和资源。线程是轻量级的，创建、切换和销毁线程比进程要快。

2. **资源开销：**
   - 进程之间的资源开销较大，因为每个进程都有自己的独立地址空间和系统资源。
   - 线程之间共享相同的地址空间和系统资源，因此线程的创建和切换开销较小。

3. **通信机制：**
   - 进程之间通信需要使用额外的机制，如管道、信号量、消息队列等。
   - 线程之间通信更加简单，直接通过**共享内存**等方式就可以实现。

4. **并发性：**
   - 不同进程之间是并发执行的，一个进程的执行不会阻塞其他进程的运行。
   - 线程在同一进程内并发执行，*但多个线程共享进程的资源，因此线程之间可能会出现竞争条件和同步问题。*

5. **稳定性：**
   - 一个进程崩溃通常不会影响其他进程，因为它们有独立的地址空间。
   - 如果一个线程崩溃，整个进程都会受到影响，因为所有线程共享同一地址空间。

6. **创建和销毁：**
   - 创建和销毁进程的开销较大，涉及到资源的分配和回收。
   - 创建和销毁线程的开销较小，*因为它们共享进程的资源*。

7. **可扩展性：**
   - 由于进程之间相互独立，系统可以更好地利用多核处理器，实现更好的可扩展性。
   - 线程共享相同的资源，可能会面临锁和同步的问题，需要更加小心地设计和管理。

综上所述，进程和线程都是实现并发执行的方式，但它们的应用场景和特性有所不同。在设计应用程序时，需要根据具体情况来选择使用进程还是线程，以实现更高效和稳定的程序运行。

#### 数组和哈希表的区别

数组（Array）和哈希表（Hash Table）都是常见的数据结构，它们在存储和查找数据方面有一些显著的区别。

1. **存储方式：**
   - 数组：是一种线性数据结构，它使用连续的内存空间来存储相同类型的元素。数组的元素通过索引访问，索引从0开始递增。
   - 哈希表：是一种基于键-值（Key-Value）对的数据结构，它使用**哈希函数将键映射到数组的特定位置（槽位）**，从而实现快速的插入和查找。

2. **插入和查找的效率：**
   - 数组：通过索引访问元素的时间复杂度为O(1)，即常数时间。但是，对于插入和删除操作，由于需要移动其他元素，时间复杂度为O(n)，其中n为数组中的元素个数。
   - 哈希表：**在没有哈希冲突的情况下**，哈希表的插入、删除和查找操作平均时间复杂度为O(1)，即常数时间。但是，哈希冲突可能会导致查找性能下降，需要解决冲突的策略。

3. **内存占用：**
   - 数组：由于数组使用连续的内存空间存储元素，它们的大小在创建时就确定了，可能会导致空间浪费。
   - 哈希表：哈希表的大小可以动态调整，能够根据实际元素数量自动扩展和缩小，因此在存储少量元素时可以更加节省内存。

4. **键的唯一性：**
   - 数组：数组元素的索引必须是唯一的，并且范围在数组的大小内。
   - 哈希表：哈希表的键必须是唯一的，但可以是任意数据类型，不受数组大小限制。

5. **排序：**
   - 数组：数组元素通常是按照它们在数组中的位置排序的，可以进行快速的顺序遍历。
   - 哈希表：哈希表的元素没有特定的顺序，无法直接进行顺序遍历，需要使用哈希表迭代器或其他方式进行遍历。

总的来说，数组适用于对元素的顺序访问，索引访问速度非常快，但插入和删除操作的性能较差。哈希表适用于快速的查找、插入和删除操作，但可能会有哈希冲突和一些空间开销。选择合适的数据结构取决于具体的应用需求。

#### 进程同步的方法

在多进程并发执行的环境中，为了避免出现竞态条件（Race Condition）和确保数据的正确性，需要使用进程同步的方法来协调进程之间的操作。以下是一些常见的进程同步方法：

1. **互斥锁（Mutex）：**
   互斥锁是一种最常见的进程同步机制。它允许一个进程在任意时刻独占一个共享资源，其他进程必须等待该进程释放锁后才能访问共享资源。互斥锁保证了在同一时刻只有一个进程可以进入临界区（访问共享资源的区域），从而避免了竞态条件。
2. **信号量（Semaphore）：**
   信号量是一个计数器，用于控制多个进程对共享资源的访问。它允许多个进程同时访问共享资源，但可以限制并发访问的数量。当一个进程访问共享资源时，它必须先获得信号量，如果信号量计数器大于零，则减少计数器并允许访问，否则等待直到其他进程释放信号量。
3. **条件变量（Condition Variable）：**
   条件变量用于在进程之间传递信号，以便某些特定条件满足时，其他进程可以继续执行。它通常与互斥锁结合使用，等待特定条件的进程会释放互斥锁并进入阻塞状态，直到另一个进程满足条件并发出信号，唤醒等待的进程。
5. **读写锁（Read-Write Lock）：**
   读写锁允许多个进程同时读取共享资源，但在有写操作时需要互斥地独占资源。这对于读多写少的场景可以提高并发性能。
6. **自旋锁（Spin Lock）：**
   自旋锁是一种忙等待锁，当一个进程尝试获得锁时，如果发现锁已被其他进程占用，它会一直循环（自旋）等待直到锁被释放。自旋锁适用于临界区很短的情况。

选择合适的进程同步方法取决于具体的应用场景和需求。不同的同步方法会对性能产生不同的影响，因此在设计多进程应用程序时，需要仔细考虑数据的访问模式和并发需求来做出合理的选择。

##### 事件

在进程同步中，**"事件"通常指的是同步机制中使用的信号或通知**，用于通知其他进程某个特定的条件已经满足，从而触发其他进程的相应操作。这些事件是用于进程之间进行通信和协调的一种方式。

具体来说，进程同步中的事件可以包括：

1. **信号量的信号（Signal）：**
   信号量是一种常用的进程同步机制，其中的信号可以用来通知其他进程某个条件已经满足，其他进程可以通过等待信号量的操作（P操作）来监听这个信号，并在信号到来时得到通知。

2. **条件变量的信号（Signal）：**
   条件变量是在互斥锁的基础上实现进程间通信的一种方式。当一个进程满足了某个条件时，它可以通过条件变量发送信号，其他等待这个条件的进程就会被唤醒。

3. **事件通知：**
   在某些操作系统或框架中，有专门的事件通知机制，允许进程监听和响应特定事件的发生。例如，一个进程可能等待某个文件的修改事件，当文件被修改时，操作系统会发出事件通知，进程可以接收到通知并执行相应的处理。

4. **屏障（Barrier）：**
   在多线程编程中，屏障也是一种用于进程同步的事件。当所有参与的进程都到达屏障点时，屏障就会打开，所有进程可以继续执行后续的操作。

这些事件通知机制允许进程之间进行相互的通信和同步，从而实现协调的并发执行。通过使用这些事件，进程可以根据特定的条件来等待、唤醒或者触发其他进程的操作，从而实现复杂的进程间交互和协作。

在C++的pthread库中，没有直接提供事件(Event)的概念，但我们可以通过其他机制模拟实现事件的功能。一个常用的方法是使用**条件变量（pthread_cond_t）和互斥锁（pthread_mutex_t）结合使用来实现事件通知。**

```C++
//测试进程同步时的事件机制 pthread库使用的是pthread_cond_t pthread_mutex_t

#include<iostream>
#include<pthread.h>
#include<unistd.h>
using namespace std;

pthread_mutex_t mtx=PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond=PTHREAD_COND_INITIALIZER;
bool eventOccurred = false;

void* WaitEvent(void* args)
{
    int id=*(int*)args;
    pthread_mutex_lock(&mtx);
    while(!eventOccurred)//事件不就绪
    {
        cout<<"thread["<<id<<"]is waiting!"<<endl;
        pthread_cond_wait(&cond,&mtx);//先将锁释放,等到条件就绪再第一时间获取到锁
    }
    //被唤醒之后继续执行之后的代码
    std::cout << "Event occurred! Thread " << id << " is continuing." << std::endl;
    pthread_mutex_unlock(&mtx);
    pthread_exit(nullptr);
    return nullptr;
}
int main()
{
#define NUM 2
    pthread_t tid[NUM];
    for(int i=0;i<NUM;i++)
    {
        pthread_create(&tid[i],nullptr,WaitEvent,(void*)(&tid[i]));
    }

    sleep(2);//模拟时间就绪等待
    pthread_mutex_lock(&mtx);
    eventOccurred=true;
    //cond通知
    pthread_cond_broadcast(&cond);//通知所有等待的线程当线程收到通知后，会从条件变量的等待中返回，并继续执行。
    cout<<"I had broadcast all thread!"<<endl;
    // pthread_cond_signal(&cond);    
    pthread_mutex_unlock(&mtx);
    
    for(int i=0;i<NUM;i++)
    {
        pthread_join(tid[i],nullptr);
    }
    return 0;
}
```

#### 深浅拷贝

深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在编程中用于复制数据结构的两种不同方法，它们有以下区别：

1. **数据复制的含义：**
   - 深拷贝：在深拷贝中，会复制源数据结构的所有元素，包括元素本身以及元素引用的对象或数据结构。这意味着在深拷贝后，**源数据结构和目标数据结构是完全独立的**，修改目标数据结构不会影响源数据结构。
   - 浅拷贝：在浅拷贝中，**只复制源数据结构的引用或指针，不会复制元素本身**。这意味着在浅拷贝后，**源数据结构和目标数据结构共享相同的元素**，修改目标数据结构可能会影响源数据结构。
4. **适用场景：**
   - 深拷贝：当需要完全独立的数据结构副本，并且对副本的修改不应影响原始数据结构时，使用深拷贝。
   - 浅拷贝：当需要共享相同数据结构，且对副本的修改需要反映到原始数据结构时，使用浅拷贝。

在C++中，如果使用**自定义类或动态分配的内存**（例如通过new关键字创建的对象或数组），需要特别注意进行深拷贝或浅拷贝的处理。对于自定义类，通常需要实现自定义的拷贝构造函数和赋值运算符重载来确保正确地进行深拷贝或浅拷贝。

#### 虚函数表

在C++中，每个类只有一个虚函数表（Virtual Function Table），无论这个类有多少个对象实例。虚函数表是用于支持多态性（Polymorphism）的一种机制，它包含了类中所有虚函数的地址，允许在运行时通过对象的指针或引用来调用正确的虚函数。

虚函数表在类的内存布局中通常作为类的第一个成员，因此每个类的实例都共享同一个虚函数表。当类中声明了虚函数时，编译器会自动创建并初始化虚函数表。

在继承关系中，**如果派生类重新实现了基类的虚函数，那么派生类的虚函数表会覆盖基类的虚函数表，从而允许正确地调用派生类的虚函数**。这样的特性使得C++实现了运行时的多态性，允许在运行时根据对象的实际类型来调用正确的虚函数

#### 野指针空指针区别

野指针（Wild Pointer）和空指针（Null Pointer）是两种在编程中经常谈及的指针概念，它们有不同的含义和特征。

1. **空指针（Null Pointer）**：
   空指针是一个特殊的指针值，它不指向任何有效的内存地址。在大多数编程语言中，空指针的值通常表示为0（整数值0）或者使用特定的预定义宏或关键字表示。空指针用于表示指针不引用任何对象或内存块。在访问空指针所指向的内存时，由于没有有效的地址，会导致程序错误，通常是空指针解引用（dereference）导致的崩溃。

   示例（C++）：
   ```cpp
   int* ptr = nullptr; // 或 int* ptr = NULL; 或 int* ptr = 0;
   ```

   注意：空指针是一个特殊的指针值，它本身占用内存中的一些存储空间（通常是指针的大小），因此它有自己的地址。

2. **野指针（Wild Pointer）**：
   野指针是指指向一个未知或无效内存地址的指针，也就是说，它不指向任何有效的对象或内存块，或者指向已经释放的内存。野指针通常是由于指针没有被初始化、指针在释放后未置空或者指针越界访问等情况下产生的。

   示例（C++）：
   ```cpp
   int* ptr; // 这是一个野指针，未被初始化
   delete ptr; // 释放内存后未置空，成为野指针
   int arr[5];
   int* ptr = &arr[10]; // 指针越界，ptr成为野指针
   ```

   野指针是一个不安全的编程错误，它可能导致程序崩溃、未定义行为或者难以察觉的错误。为了避免野指针问题，建议在定义指针时初始化为nullptr（C++）或NULL（C）。

总结：空指针表示指针没有指向有效的内存地址，而**野指针表示指针指向一个未知或无效的内存地址**。空指针有自己的地址，而野指针则可能指向任何的地址，因为它没有经过初始化或者已经失去了有效指向。在编程中，应该尽量避免使用野指针，要保证指针在使用前正确初始化，并在释放内存后将指针置空，以避免产生不可预期的问题。

#### shared_ptr是线程安全的

在C++标准库中，`std::shared_ptr` 是一种智能指针，用于管理动态分配的资源，主要是为了避免内存泄漏和正确地释放资源。`std::shared_ptr` 是线程安全的，但有一些需要注意的地方。

1. **引用计数**：
   `std::shared_ptr` 使用引用计数来追踪有多少个智能指针共享同一个资源（通常是一个动态分配的对象）。每当创建新的 `shared_ptr` 来管理同一资源时，引用计数就会增加，当 `shared_ptr` 被销毁或者不再引用该资源时，引用计数减少。当引用计数降至零时，资源会被自动释放。引用计数的线程安全性由 `shared_ptr` 内部维护。

2. **复制 `shared_ptr` 的线程安全性**：
   `shared_ptr` 的复制通常是线程安全的。当一个 `shared_ptr` 被多个线程同时复制时，其引用计数会同步更新，确保引用计数正确地反映共享资源的使用情况。

3. **资源的访问**：
   `shared_ptr` 内部的引用计数是线程安全的，但是对于资源本身的访问是不受保护的。如果多个线程同时访问 `shared_ptr` 指向的资源，并对资源本身进行修改，就可能会导致竞态条件和数据损坏。为了避免这种情况，应该使用其他同步机制（例如互斥锁或原子操作）来保护资源的访问。

4. **原子引用计数**：
   C++11引入了原子引用计数的 `std::shared_ptr` 实现，它在多线程环境下保证了引用计数的原子操作。这种实现消除了引用计数的竞态条件，从而增加了 `shared_ptr` 的线程安全性。

总的来说，`std::shared_ptr` 是线程安全的，特别是在C++11引入的原子引用计数实现后，它提供了更好的多线程支持。但是，需要注意的是，即使 `shared_ptr` 是线程安全的，对于资源本身的并发访问仍然需要额外的线程同步措施，以确保资源的正确使用和修改。

#### mutex和MYSQL中的读写锁区别

`mutex` 和 MySQL 中的读写锁是两种不同的锁机制，它们在实现上有一些区别，用途也不同。下面是它们的主要区别：

1. **用途和领域**：
   - `mutex`（互斥锁）：`mutex` 是一种基本的线程同步机制，用于保护共享资源的访问，**确保同一时间只有一个线程可以访问共享资源**。它主要用于在多线程编程中防止并发访问导致的数据竞争和数据损坏。
   - MySQL 中的读写锁：MySQL 中的读写锁是数据库层面的锁机制，用于管理**对数据库中数据的并发访问**。读写锁允许多个读操作并发执行，但只允许一个写操作，以确保在写操作时没有其他读或写操作对数据进行干扰。

2. **粒度**：
   - `mutex` 是较细粒度的锁：它通常是对一个或者一小组数据进行保护，比如某个变量或者数据结构。只有在需要访问这个特定数据时，线程才会请求和获得 `mutex`。
   - MySQL 中的读写锁是较粗粒度的锁：它通常是对整个数据库表或者数据库的一部分进行保护。读写锁的目的是在多个事务之间提供对数据的并发访问控制。

3. **并发性**：
   - `mutex` 的并发性较低：由于 `mutex` 只允许一个线程访问共享资源，多个线程可能会因为竞争 `mutex` 而被阻塞，导致并发性降低。
   - MySQL 中的读写锁的并发性较高：读写锁允许多个读操作并发执行，提高了数据库读取的并发性。但当有写操作时，写锁会阻塞其他读和写操作，确保数据一致性。

4. **使用场景**：
   - `mutex` 适用于多线程编程的场景，用于保护共享资源的安全访问。
   - MySQL 中的读写锁适用于数据库的并发访问场景，用于提供读取的并发性和写操作的独占性。

总结：`mutex` 是用于多线程编程的基本锁机制，用于保护共享资源的访问。MySQL 中的读写锁是数据库层面的锁机制，用于提供对数据库数据的并发访问控制。它们的用途、粒度和并发性有所不同，因此在使用时要根据具体的应用场景和需求进行选择。

##### mutex原理

`mutex` 的原理是通过**操作系统提供的底层同步原语**来实现的，通常是使用操作系统的**原子操作和硬件支持**。

`mutex` 的实现通常使用操作系统提供的等待与唤醒机制来实现线程的阻塞和唤醒。当一个线程请求 `mutex`，但其它线程已经占有了这个 `mutex` 时，该线程会被放入等待状态，并被阻塞。当占有 `mutex` 的线程释放了 `mutex`，操作系统会唤醒其中一个等待的线程，让它去竞争 `mutex`。

总的来说，`mutex` 的原理是基于原子操作和硬件支持，结合操作系统的等待与唤醒机制来实现的。通过 `mutex`，能够确保共享资源的安全访问，避免了多线程之间的竞争问题，保障了多线程程序的正确执行。

#### Makefile

Makefile 是一种用于管理软件项目构建和编译的工具，它基于一种叫做 "make" 的工具。Makefile 的原理是**通过指定一系列规则和依赖关系**，告诉 "make" 工具如何**根据源代码文件生成目标文件**，从而构建最终的可执行程序或库。

以下是 Makefile 的基本原理和工作流程：

1. **Make 工具**：
   "make" 是一个在命令行中运行的工具，用于解析和执行 Makefile 文件。它检查源代码文件的时间戳，通过比较依赖关系和规则，判断哪些文件需要重新编译，然后调用对应的编译器来重新生成目标文件。

2. **Makefile 文件**：
   Makefile 是一个文本文件，通常名为 "Makefile" 或 "makefile"（注意大小写敏感）。Makefile 中包含了一系列规则，每个规则描述了如何根据源文件生成目标文件，并可以指定依赖关系。

3. **规则**：
   每个 Makefile 规则通常由以下部分组成：
   ```
   target: dependencies
       command
   ```
   - `target` 是生成的目标文件的名称。
   - `dependencies` 是生成目标文件所依赖的源文件或其他目标文件。
   - `command` 是执行的命令，用于根据依赖文件生成目标文件。

4. **依赖关系**：
   Makefile 中的规则描述了目标文件和源文件之间的依赖关系。如果目标文件依赖于某些源文件或其他目标文件，当这些依赖文件的时间戳较新时，"make" 工具会重新编译目标文件。

5. **默认规则**：
   如果 Makefile 中没有显式指定生成目标文件的规则，"make" 工具会尝试使用默认规则来生成目标文件。默认规则根据文件的扩展名推断所使用的编译器和选项。

6. **递归执行**：
   Makefile 可以包含多个规则，甚至可以嵌套调用其他 Makefile。在这种情况下，"make" 工具会递归地执行被调用的 Makefile。

7. **自动变量**：
   Makefile 支持一些自动变量，例如 `$@` 表示目标文件的名称，`$<` 表示第一个依赖文件的名称，`$^` 表示所有依赖文件的列表等。这些自动变量可以使 Makefile 编写更加简洁和灵活。

总的来说，Makefile 的原理是基于一系列规则和依赖关系来描述源代码和目标文件之间的转换过程。通过 Make 工具的解析和执行，根据文件的时间戳判断哪些文件需要重新编译，从而实现高效的软件项目构建和编译。

#### epoll中红黑树作用

`epoll` 是 Linux 系统中一种高效的 I/O 复用机制，用于处理大量的并发网络连接。在 `epoll` 中，红黑树（Red-Black Tree）是其中一种数据结构，它的作用是用于**快速查找并管理事件**（文件描述符）。

`epoll` 使用红黑树的原因是**为了能够高效地管理大量的文件描述符**。在大规模并发网络编程中，存在大量的连接需要监听，并且连接的活动状态可能随时变化。使用传统的阻塞 I/O 或者多路复用 I/O（如 `select` 或 `poll`）来处理大量连接会遇到**性能瓶颈**，因为需要遍历所有连接来查找活动的事件。

而红黑树是一种自平衡的二叉搜索树，具有以下特性：

1. 保持数据有序：红黑树中的节点按照键值的大小进行有序排列，这使得在红黑树中可以更快速地查找某个特定的节点。

2. 快速插入和删除：红黑树的插入和删除操作的时间复杂度为 **O(log n)**，保持了高效的数据结构特性。

在 `epoll` 中，红黑树被用来**管理已经注册的文件描述符和事件**，以及快速查找活动的文件描述符。每个注册的文件描述符都是红黑树的一个节点，**文件描述符作为键值进行排序**。当有新事件到来时，可以快速在红黑树中查找对应的文件描述符节点，从而处理事件。这使得 `epoll` 能够高效地处理大量的连接，同时减少了遍历所有连接的开销。

总结：`epoll` 使用红黑树来高效地管理大量的文件描述符，以便快速查找和处理活动的网络事件。红黑树作为数据结构在 `epoll` 中的使用，使得 `epoll` 在高并发环境下具有卓越的性能。

#### 用户态内核态

用户态（User Mode）和内核态（Kernel Mode）是计算机操作系统中的两种运行模式，分别用于执行**用户进程和操作系统内核代码**。它们在功能和权限上有所不同，切换是通过系统调用和异常处理机制实现的。

1. **用户态**：
   - 在用户态下运行的进程只能访问有限的资源，如用户进程自身的内存空间和有限的设备。
   - 用户态下的进程没有直接访问操作系统核心的权限，不能执行特权指令和访问敏感资源。
   - 用户态是一个相对安全的执行环境，因为用户进程之间互相隔离，**不会直接影响操作系统的稳定性和安全性。**

2. **内核态**：
   - 在内核态下运行的代码拥有操作系统的全部权限，可以执行特权指令和访问所有系统资源，如设备、内存和中断处理等。
   - 内核态的代码可以直接操作硬件，执行敏感的系统操作。
   - 内核态是一个特权执行环境，只有操作系统内核和与之紧密关联的驱动程序才能运行在内核态。

3. **切换机制**：
   - 用户态切换到内核态：当用户进程需要访问内核态的资源或执行特权操作时，**需要通过系统调用（syscall）**来请求操作系统的帮助。系统调用会触发从用户态切换到内核态的过程，将控制权交给操作系统内核。在内核态中，操作系统会处理系统调用请求，完成所需的操作后，再切换回用户态将结果返回给用户进程。

   - 内核态切换到用户态：当操作系统完成了用户进程请求的操作，需要将控制权交还给用户进程时，会通过异常处理机制（如中断或异常）将控制权从内核态切换回用户态。用户进程继续执行自己的代码。

这种用户态和内核态之间的切换机制保证了操作系统的稳定性和安全性。用户态提供了隔离的执行环境，用户进程不能直接影响操作系统的运行；而内核态则提供了操作系统内核的全部权限，使得操作系统能够对系统资源进行管理和控制。通过系统调用和异常处理，用户态和内核态之间的切换能够实现高效的系统资源访问和操作。

#### 进程创建时需要系统分配什么资源

进程是计算机中的基本执行单位，创建一个新的进程需要操作系统为其分配一系列资源，以便进程能够独立地运行和执行任务。下面是创建进程时需要操作系统分配的主要资源：

1. **内存空间**：
   当创建一个新进程时，操作系统需要为该进程分配**一块独立的内存空间**，用于存储进程的代码、数据和堆栈。进程的代码和数据位于代码段和数据段中，而堆栈用于存储函数调用和局部变量等。

2. **程序映像**：
   进程的程序映像是指进程的可执行文件，包含了进程的二进制代码和数据。在进程创建时，操作系统需要将可执行文件加载到进程的内存空间中，使得进程能够执行其中的代码。

3. **文件描述符**：
   进程在执行过程中可能需要访问文件、设备和网络等资源。在进程创建时，操作系统会为进程分配一组文件描述符表，用于标识进程所打开的文件和设备。

4. **进程控制块（Process Control Block，PCB）**：
   PCB 是操作系统用于管理进程的一种数据结构，它包含了进程的各种信息，如进程状态、程序计数器、寄存器内容、内存分配情况、优先级等。在进程创建时，操作系统会为新进程分配一个 PCB。

5. **进程标识符（Process Identifier，PID）**：
   每个进程都有一个唯一的进程标识符，用于在操作系统中标识不同的进程。在进程创建时，操作系统会为新进程分配一个唯一的 PID。

6. **用户权限**：
   操作系统需要为新进程分配适当的用户权限，以确定进程能够访问的资源范围。这样可以保护系统的安全性，防止进程越权访问。

创建进程的过程由操作系统负责，它会在适当的时候为新进程分配这些资源，并设置进程的初始状态，使得进程能够正常运行。创建进程是操作系统的一项核心任务，它确保了进程的独立性和资源隔离，使得多个进程能够同时运行，互不干扰。

#### lock_guard和智能指针

`lock_guard` 和智能指针是 C++ 中两个不同的概念，它们用于不同的场景，但在某些情况下可以结合使用来提高代码的安全性和可维护性。

1. **lock_guard**：
   `std::lock_guard` 是 C++ 标准库中的一个类模板，**用于在多线程环境中保护临界区的访问，防止多个线程同时修改共享资源**。`lock_guard` 通过构造函数在临界区的入口获取锁，通过析构函数在临界区的出口释放锁，从而确保在离开临界区时，锁会被正确释放。

   示例：
   ```cpp
   #include <mutex>
   
   std::mutex mtx;
   int shared_data = 0;
   
   void someFunction() {
       std::lock_guard<std::mutex> guard(mtx); // 获取锁
       // 在临界区内进行对共享资源的访问和修改
       shared_data++;
       // 锁会在 guard 离开作用域时自动释放
   }
   ```

2. **智能指针**：
   智能指针是 C++ 标准库中的一组类，用于管理动态分配的资源，特别是用于自动化资源的释放。常见的智能指针包括 `std::shared_ptr`、`std::unique_ptr` 和 `std::weak_ptr`。这些智能指针使用引用计数或者独占权的方式来管理资源，从而避免内存泄漏和资源释放的问题。

   示例：
   ```cpp
   #include <memory>
   
   void someFunction() {
       std::shared_ptr<int> ptr = std::make_shared<int>(42); // 创建智能指针
       // 使用 ptr 指向的资源
       // 当 ptr 离开作用域时，资源会自动释放
   }
   ```

3. **联系**：
   `lock_guard` 和智能指针可以结合使用，特别是在多线程环境下管理共享资源时。例如，在多线程的情况下，如果多个线程需要共享一个资源，并且使用**智能指针来管理该资源的生命周期**，可以在临界区内使用 `lock_guard` 来保护对该资源的访问，防止多个线程同时修改导致竞争条件的问题。

   这样的组合可以在多线程编程中提供更好的资源管理和线程安全性，确保共享资源在被访问时只有一个线程能够访问，并在不再被使用时正确释放资源。