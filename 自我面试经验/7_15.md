### weak_ptr的作用

`std::weak_ptr` 是用于解决循环引用问题的工具，它可以打破 `std::shared_ptr` 形成的强引用环。`std::weak_ptr` 允许观察（而非拥有）被 `std::shared_ptr` 管理的对象，而不会增加对象的引用计数。

`std::weak_ptr` 主要用于解决循环引用导致的内存泄漏问题。当存在循环引用时，对象间的 `std::shared_ptr` 引用计数无法归零，导致对象无法被正确地销毁，从而造成内存泄漏。通过使用 `std::weak_ptr`，可以将其中一个或多个对象的引用设置为弱引用，这样它们不会增加引用计数，也不会阻止对象的销毁。

`std::weak_ptr` 具有以下特性和用法：

1. 创建 `std::weak_ptr`：可以通过将 `std::weak_ptr` 初始化为 `std::shared_ptr` 或通过 `std::shared_ptr` 的 `weak_ptr` 成员函数创建。

2. 使用 `std::weak_ptr`：可以使用 `std::weak_ptr` 的 `lock` 成员函数获取一个有效的 `std::shared_ptr` 对象，以便访问所管理的对象。`lock` 会检查 `std::shared_ptr` 是否仍然有效，如果有效则返回一个持有对象的 `std::shared_ptr`，否则返回一个空的 `std::shared_ptr`。

3. 判断 `std::weak_ptr` 是否过期：可以使用 `expired` 成员函数检查 `std::weak_ptr` 是否过期（即所管理的对象是否已被销毁）。如果 `expired` 返回 `true`，表示 `std::shared_ptr` 已经被销毁，对象不再可用；如果返回 `false`，则仍有有效的 `std::shared_ptr` 对象可以访问。

通过使用 `std::weak_ptr`，可以打破循环引用的强引用环，允许对象在不再被使用时正常地销毁，避免内存泄漏。

##### 成员函数和作用

`std::weak_ptr` 是 C++11 标准中引入的一种智能指针，用于协助管理共享对象的生命周期。它通常用于解决 `std::shared_ptr` 所带来的循环引用问题。`std::weak_ptr` 具有以下主要成员函数和作用：

1. `std::weak_ptr::weak_ptr()`: 默认构造函数，创建一个空的 `weak_ptr` 对象。

2. `std::weak_ptr::weak_ptr(const std::shared_ptr<T>& shared_ptr)`: 从一个 `std::shared_ptr` 创建一个 `weak_ptr`，可以通过调用 `weak_ptr.lock()` 来获取一个与之关联的 `std::shared_ptr`。**如果原始的 `shared_ptr` 已经释放了资源，通过 `weak_ptr.lock()` 获得的指针将会为空。**

3. `std::weak_ptr::weak_ptr(const std::weak_ptr<T>& other)`: 复制构造函数，创建一个指向与另一个 `weak_ptr` 共享相同资源的新 `weak_ptr` 对象。

4. `std::weak_ptr::~weak_ptr()`: 析构函数，释放 `weak_ptr` 对象所管理的资源（如果有的话）。

5. `std::weak_ptr::expired()`: 检查与当前 `weak_ptr` 关联的资源是否已经被释放。如果资源已经释放，返回 `true`，否则返回 `false`。

6. `std::weak_ptr::lock()`: 尝试获取与当前 `weak_ptr` 关联的资源的 `std::shared_ptr`，如果资源已经被释放，则返回一个空的 `std::shared_ptr`。

`std::weak_ptr` 主要用于**解决循环引用问题**，当多个 `std::shared_ptr` 相互引用，导致资源无法正常释放时，可以使**用 `std::weak_ptr` 来打破其中一条引用链**，以避免资源泄漏。在需要访问资源时，可以使用 `lock()` 方法来获得一个有效的 `std::shared_ptr`，如果资源已经被释放，`lock()` 将返回一个空的 `std::shared_ptr`。

总之，`std::weak_ptr` 是一种非拥有型的智能指针，它允许你观察和共享 `std::shared_ptr` 所管理的资源，但不会增加资源的引用计数，也不会影响资源的生命周期。这使得它在处理共享资源的循环引用问题时非常有用。

#### 虚拟地址如何转化为物理地址

虚拟地址空间划分：计算机系统将虚拟地址空间划分为多个页面（或页），每个页面的大小通常是固定的。这个过程通常由操作系统的**内存管理单元MMU**完成。

虚拟地址解析：当应用程序引用一个虚拟地址时，CPU会将该虚拟地址发送到内存管理单元进行解析。

页表查找：内存管理单元**使用页表来映射虚拟地址到物理地址**。页表是一个数据结构，它存储了**虚拟地址和对应的物理地址之间的映射关系**。页表的结构可以是层次化的，以提高查找效率。

虚拟地址转换：内存管理单元根据页表中的映射关系，将虚拟地址的页面部分与页表中的条目匹配，以找到对应的物理页面。

物理地址生成：一旦找到了虚拟地址对应的物理页面，内存管理单元**将物理页面的基地址**与**虚拟地址的页面内偏移相加**，生成最终的物理地址。

访问物理地址：CPU使用物理地址从内存中读取或写入数据。

##### 页表作用

是一种数据结构,主要存储虚拟地址到物理地址的映射关系.由操作系统管理,由内存管理单元在虚拟地址转化为物理地址的时使用.

##### 页表构成

每一个页表由**页表项**组成,每一个页表项对应虚拟地址空间中的一个页面或者页帧.包含虚拟页号,物理页帧号,访问权限,页面状态.

1. 虚拟页号VPN:虚拟地址的一部分,用于在页表中查找对应的页表项.
2. 物理页帧号PFN:指示**虚拟页面在内存中的位置**,**存储对应的物理页帧号**
3. 访问权限和控制位:包含对**虚拟页面的访问权限的位**,读写执行权限,以及其他控制位.
4. **页面状态位**:指示当**前虚拟页面是否有效.**
5. 脏位:该虚拟页面是否被修改过.



![image-20230715142127657](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230715142127657.png)



#### 操作系统如何实现原子操作

原子操作是指在**并发环境**下，能够被视为**单个不可分割的操作**。它要么完全执行，要么完全不执行，不会出现部分执行的情况。

##### 自旋锁

Linux内核提供了**自旋锁**机制，用于**保护临界区的原子访问**。自旋锁基于忙等待的方式，当一个线程尝试获取锁时，如果锁已被占用，则该线程将忙等待直到锁可用。Linux提供了多种类型的自旋锁，如原子自旋锁（atomic_spinlock_t）和读写自旋锁（rwlock_t）。**自旋锁通过底层的原子操作来实现，**以确保对锁的获取和释放操作是原子的。

##### 原子操作宏

Linux内核提供了一些原子操作的宏，如`atomic_t`和`atomic64_t`，用于操作整数类型的变量。这些宏利用了底层的**硬件支持，例如处理器提供的原子指令，以实现原子性**。通过这些宏，可以对变量进行原子的读取、写入和修改操作，以确保并发访问的正确性。

##### 信号量

Linux内核还提供了信号量机制，**用于同步和互斥访问共享资源**。信号量可以用于**限制对资源的并发访问**，并确保原子操作的执行。

##### 内存屏障（Memory Barriers）

内存屏障是一种机制，用于控制指令的执行顺序和内存访问的可见性。**在并发编程中，内存屏障可以用来确保原子操作的正确性**。这些内存屏障可以通过内联汇编或特殊的内存屏障函数来使用，以确保原子操作的顺序性和一致性。如读写内存屏障（read-write memory barrier）和写读内存屏障（write-read memory barrier）

#### C++内存分布

![image-20230715153940580](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230715153940580.png)

##### bss段

.bss段是用于存储未初始化的全局变量和静态变量的内存段，**它在程序启动时会被清零并延迟初始化**。它位于已初始化数据段和堆之间，**大小在程序运行时确定**。.bss段在程序启动时会被清零，因此其中的变量在程序开始执行之前会被**初始化为默认值（通常为0或null）**。这种延迟初始化的机制可以节省可执行文件的大小，因为**不需要将未初始化变量的默认值保存在可执行文件中，而是在运行时进行初始化。**

#### 内存对齐

是指在**分配和访问内存**时,**将数据结构或变量的起始地址对齐到特定的边界**.内存对齐可以提高程序的性能和可移植性.这个边界通常是数据类型的大小或者是处理器的请求.

##### 原因

性能：许多计算机体系结构和处理器对未对齐的访问有额外的开销。对于大部分的数据类型，处理器要求其起始地址必须是特定的边界的倍数。如果数据没有对齐，**处理器可能需要多次访问内存**，或者执行额外的指令来处理未对齐的数据，从而导致性能下降。

缓存利用：现代计算机体系结构中的高速缓存是按照缓存行（Cache Line）来组织的，每个缓存行的大小通常为几十字节或更大。如果数据没有对齐，可能会跨越多个缓存行，从而导致额外的缓存行加载和未使用的字节，浪费了缓存的空间和带宽.

**平台兼容性**：某些硬件平台对内存对齐有严格要求。例如，某些处理器可能只能从对齐的地址读取或写入数据，否则可能会导致硬件异常或错误。通过进行内存对齐，可以提高程序在不同平台上的兼容性和可移植性。

#### push_back vs emplace_back

总结来说，`push_back`用于**将已存在的对象的副本**添加到向量末尾，它会**创建一个临时对象**，然后将该对象的副本添加到向量中。这意味着在插入新元素时，会调用元素类型的**拷贝构造函数**来创建临时对象，并进行一次内存拷贝操作。

而`emplace_back`用于直接在向量末尾构造新元素，避免了对象的复制和拷贝操作。如果**元素类型是可移动的而非可复制的**，使用`emplace_back`可以提高性能，因为它避免了多余的复制操作。对于简单的类型，两者的差异可能不明显，但对于复杂的类型或代价较高的拷贝操作，`emplace_back`通常是更高效的选择。

#### 内联函数

内联函数是一种编译器优化的技术，它用于在调用处直接展开函数的代码，而不是通过函数调用来执行。内联函数通常通过在函数定义前加上`inline`关键字来声明。

##### 优点

减少函数调用开销:减少函数压栈出栈引入的额外开销.不需要额外的调整指令,提高执行效率.

##### 缺点

代码膨胀,编译时间增长,冗余代码增加造成可维护性下降.

#### 宏 vs内联函数

1. 宏是在**预处理阶段**进行文本替换,内联函数在编译阶段进行代码展开.
2. 宏替换时**并不做语法和类型检查,**直接替换不受语法限制;内联函数编译阶段要进行类型和语法检查,确保参数和返回值都正确.
3. 宏展开之后的代码是**替换完成的代码,不方便进行错误定位和调试**.内联函数可以在**调试时直接到内联函数内部.**
4. 宏：宏的展开会直接复制代码，增加代码量和可执行文件大小。宏的使用过度可能会导致代码膨胀。内联函数：内联函数的展开是通过编译器进行的，可以减少代码量和可执行文件大小。

#### #define vs typedef

`#define`：`#define`是C/C++中的预处理指令，用于**创建宏定义**。它是一种文本替换机制，将指定的文本或代码片段替换为预定义的值或表达式。**它可以用于创建常量、宏函数以及任意文本代码片段的替换。**

`typedef`：`typedef`是C/C++中用于**为已存在的类型创建别名的关键字**。它用于创建新的类型名称，使其成为现有类型的同义词。`typedef`通常用于提高代码的可读性和可维护性，以及为复杂的类型声明引入别名。

```C++
#define PI 3.14
#define MAX(a,b) ((a)>(b)?(a):(b))

typedef unsigned int  uint;
typedef struct Node
{}node;
```

1. typedef具有**类型检查**,#define没有类型检查,不受语法约束
2. typedef是对**已有的类型**进行别名,#define可以实现任意文本的直接替换
3. typedef是在编译阶段创建新类型,#define是在预处理阶段进行文本替换

#### TTL 

TTL（Time to Live）是一个网络数据包头部的字段，用于**限制数据包在网络中的生存时间**。它表示数据包在网络中可以经过的**最大路由跳数**或者时间跨度，以防止数据包在网络中无限循环或长时间滞留。

TTL的单位**不是实际的时间，而是经过的路由跳数**。每经过一个路由器，TTL的值会减少1。当TTL的值达到0时，数据包会被丢弃，并向源主机发送一个"Time Exceeded"错误消息。这样可以确保数据包在网络中不会无限循环或长时间滞留。

##### 如何设置

1. 在**路由器上设置**：路由器是网络中的关键设备，负责将数据包从源主机转发到目标主机。路由器通常可以设置TTL的值，以**控制数据包经过的最大跳数**。通过在路由器上设置TTL，可以限制数据包在网络中传输的范围。
2. 在**操作系统中**设置：操作系统通常提供了控制TTL的参数或命令。例如，在Windows操作系统中，可以使用`ping`命令来指定TTL的值。**在Linux或Unix操作系统中，可以使用`ping`命令的`-t`参数来设置TTL。**
3. 在编程中设置：在网络编程中，可以使用编程语言提供的网络库或API来设置TTL。例如，**使用C++的套接字编程，可以使用`setsockopt`函数并指定`IP_TTL`选项来设置TTL的值。**