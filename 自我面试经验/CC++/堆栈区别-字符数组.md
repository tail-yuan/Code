### 堆和栈的区别

#### 1申请方式

- 栈：**由系统自动分配**。例如在声明函数的一个局部变量int b，系统自动在栈中为b开辟空间。
- 堆：**需要程序员自己申请**，并指明大小，在C中用malloc函数；在C++中用new运算符。

#### 2申请后系统的响应

- 栈：只要**栈的剩余空间大于所申请的空间**，**系统将为程序提供内存**，否则将报异常提示栈溢出。
- 堆：**操作系统有一个记录空间内存地址的链表**，当系统收到程序的申请时，会遍历链表，**寻找第一个空间大于所申请空间的堆节点，然后将节点从内存空闲节点链表中删除，并将该节点的空间分配给程序**。对于大多数操作系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的对节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入到链表中。

#### 3 申请大小的限制

- 栈：在Windows下，**栈是向低地址拓展的数据结构，是一块连续的内存的区域**。站定地址和栈的大小是系统预先规定好的，**如果申请的内存空间超过栈的剩余空间，将提示栈溢出**。
- 堆：堆是**向高地址拓展的内存结构**，是不连续的内存区域。是系统用链表存储空闲内存地址的，**不连续**。

#### 4申请效率的比较

- 栈：由系统自动分配，速度较快。但程序员无法控制。
- 堆：由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来方便。 拓展：在Windows操作系统中，最好的方式使用VirtualAlloc分配内存。不是在堆，不是在栈，而是在内存空间中保留一块内存，虽然用起来不方便，但是速度快，也很灵活。

#### 5堆和栈的存储内容

- 栈：在函数调用时，第一个进栈的是主函数的中的下一条指令（函数调用的下一个可执行语句）的地址，然后是函数的各个参数。在C编译器中，参数是由右往左入栈的，然后是函数的局部变量。静态变量不入栈。
- 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 数据结构方面的堆和栈与上边叙述不同。这里的堆是指优先队列的一种数据结构，第一个元素有最高的优先权；栈实际就是满足先进后出的性质的数学或数据结构。

总结： （1）heap是堆，stack是栈； （2）stack的空间由操作系统自动分配/释放，heap上的空间手动分配/释放； （3）stack空间有限，heap是很大的自由内存区； （4）C中的malloc函数分配的内存空间即在堆上，C++中对应的是new操作符。 程序在编译对变量和函数分配内存都在栈上进行，且内存运行过程中函数调用时参数的传递在栈上进行。

#### 字符数组返回值

```C++
char* f1()
{
	char p[] = "hello world";
	return p;
}
const char* f2()
{
	const char* p = "hello world";
	return p;
}
int main()
{
	cout << f1() << endl;//崩溃
	cout << f2() <<  endl;//helloworld
	return 0;
}
```

您提到的字符串文字确实存储在程序的常量区域，但在C++中，不同的声明方式会影响编译器对字符串文字的处理方式，以及对它们的指针如何使用。

1. `f1()` 函数中的方式：
   ```cpp
   char p[] = "hello world";
   return p;
   ```
   这种方式会创建一个包含字符串文字内容的字符数组 `p`，并且**将字符串文字的内容复制到该数组**中。因此，`p` 是一个指向局部数组的指针，该数组在函数结束后被销毁，因此返回指向已经无效的内存地址。在这种情况下，解引用 `ret` 指针是不安全的。

2. `f2()` 函数中的方式：
   ```cpp
   const char* p = "hello world";
   return p;
   ```
   这种方式将字符串文字的地址存储在指向常量字符的指针 `p` 中。由于字符串文字本身在常量区域，所以这是一个安全的做法，因为 `p` 指向的内存区域在程序的生命周期内是有效的。在这种情况下，直接输出 `p` 的值是安全的，不需要解引用。

所以，关键区别在于 `f1()` 返回的是一个指向局部数组的指针，而 `f2()` 返回的是一个指向常量字符的指针。指向局部数组的指针在函数结束后变得无效，而指向常量字符的指针则可以在函数外部使用，因为它指向的内存区域在整个程序的生命周期内都是有效的。