### 中断

CPU对系统发生的某事件的一种响应,停止正在执行的程序,保留现场后自动去执行中断处理程序.

##### 外中断: 通常意义上的中断

由于外部设备事件所引起的中断,支持CPU和硬件设备之间的同步.比如磁盘IO中断.

##### 内中断: 异常

由于CPU内部事件所引起的中断,越界访问问题.

##### 意义

中断使得CPU从用户态切换到内核态,使得OS能够重新获得CPU的使用权.

维护一张中断向量表,key-val的模式,中断信号对应中断处理程序的地址.

### 协程

协程（Coroutine）是一种编程构造，用于**一般化子程序**（subroutines）以用于**非抢占式多任务**。与线程（threads）不同，协程允许多个入口点，并且可以在执行中途暂停和恢复，而不是仅从一个点开始并在一个点结束。这些特性使协程特别适用于某些编程问题，例如**协作式多任务**、**异步I/O**和**事件驱动编程**。

* 一个线程包含很多的协程,协程有自己独立的寄存器上下文数据和协程栈.该栈只在协程活动时才需要分配和管理。

* 同一个线程中的协程不需要使用互斥锁就可以访问全局变量,执行效率更高,切换效率更快.

* 可以由用户直接操作.与线程相比，协程通常更轻量级，并且全部由用户级代码管理，而不需要操作系统的介入。这可以带来更高的效率，但也意味着协程必须显式地进行任务切换。

协程的两个基本操作是`yield`和`resume`。`yield`用于暂停协程的执行并返回控制权给“调用者”，而`resume`则用于从上次`yield`的位置恢复协程的执行。

协程常用于I/O密集型任务、事件循环、状态机实现、游戏编程以及其他需要非阻塞性行为的应用.

### 非抢占式

非抢占式（Non-preemptive）是指在一个任务或进程执行时，它不会被操作系统中断或暂停，直到任务自愿放弃 CPU 控制权。这意味着任务或进程将一直运行，直到完成其工作或显式地释放 CPU，而不会被操作系统强制中断切换到其他任务。这与抢占式（Preemptive）相对，抢占式允许操作系统随时中断正在运行的任务，并将控制权转移到其他任务上。

以下是一个示例来说明非抢占式的概念：

假设有两个任务，任务 A 和任务 B，它们都要在共享的 CPU 上执行。在非抢占式系统中，任务 A 开始执行后，将完全占用 CPU 直到它完成了它的工作或自愿放弃了 CPU 控制权。这意味着任务 B 必须等待任务 A 完成，然后才能开始执行。

现实世界中的一个类比是，考虑一位演讲者（任务 A）正在讲话，而听众（任务 B）必须等待演讲者自愿停止讲话或让出话筒才能发言。在这种情况下，演讲者不会被中途打断，因此是非抢占式的。

相反，如果操作系统采用抢占式调度，那么操作系统可以在任务 A 还没有完成时中断它，将 CPU 控制权转移到任务 B，然后再返回任务 A。这种方式可以更公平地分配 CPU 时间片，并允许更快地响应紧急事件，但也需要更复杂的上下文切换和调度机制。

总之，非抢占式意味着任务只有在自愿放弃 CPU 控制权或完成工作后，才会让出 CPU，而不会被操作系统强制中断。抢占式则允许操作系统随时中断任务以执行其他任务。选择使用哪种调度方式通常取决于系统的需求和设计目标。

### IO

##### 缓存IO

将文件数据拷贝到内核缓冲区中,再拷贝到进程地址空间中.

因为有缓冲区的存在,可以实现访问文件数据时,如果缓冲区中有就可以直接返回

应用于访问频繁的小文件场景.

##### 直接IO

绕过内核缓冲区,直接将文件数据拷贝到进程地址空间.

减少数据拷贝次数,适用于不频繁的读写的大文件操作场景.

##### 裸IO

绕过文件系统直接读取磁盘块的数据.数据库中用的比较多.

### 页面置换算法

进程想要访问的页面并不在内存中,就会产生缺页中断,而恰好此时内存中页面已经满了,就需要将其中一页移除,移动到磁盘的交换区中.

##### 最佳页面置换算法opt

每次选择淘汰的页面是那种以后永远都不会使用或者在很长时间都不会访问的页面.但是无法实现.

##### 先进先出置换算法

将页面根据时序进行排序,将最早加载的页面弹出,进行置换

##### LRU置换算法(最近最久未使用)

认为之前一段时间不被访问的页面在接下来的一段时间都不会被访问.

实现时使用一个字段,记录该页面自上次被访问以来所经历的时间长度.

##### 最不常用置换算法

给每个页设置计数器,每次淘汰计数最少的页面.只考虑了访问的频率次数,而忽略了时序的问题.

如果一个页面是在之前一段时间被大量使用,count值很大,但是在这一段时间没有被使用,而是使用另一页,但是计数并没有超过count就会导致这段时间经常访问的页面被置换掉,出现误判的情况.

##### 时钟置换算法

维护一个环形链表,表指针指向最老的页面,在发生缺页中断时如果被指向的节点访问的页面标志位为0就会被直接淘汰.为1就改为0,然后再将表针迁移,直到找到下一个标志位0的页面节点.
