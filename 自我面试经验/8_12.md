### 类模版

类模板（class templates）是C++中的一种特性，用于定义参数化的类。类模板在C++编译和链接过程中经历以下几个阶段：

1. **模板定义（Template Definition）：** 在源代码中定义类模板，包括类的结构和成员函数的声明与定义。这个定义并不会生成实际的类或函数代码，只是一个模板的描述。

2. **模板实例化（Template Instantiation）：** 当使用特定的模板参数类型来创建对象或调用成员函数时，编译器会进行模板实例化。这意味着编译器会根据模板定义生成对应参数类型的实际类和函数代码。

   类模板的实例化发生在**编译阶段**，而不是运行时。当你在代码中使用一个类模板并提供实际的类型参数，编译器会根据这些类型参数生成相应的具体的类或函数，这个过程称为实例化。

   在编译阶段，编译器会根据模板的定义和实际使用情况，为每个不同的类型参数生成对应的模板实例。这些模板实例是具体的类、函数或方法，它们是在编译时生成的**，以供后续的链接和执行使用。**

   这种在编译阶段进行的实例化过程可以帮助编译器进行类型检查、优化和代码生成，以生成最终的可执行文件。这也是C++模板的一个关键特性，允许在不同的类型上重用通用的代码结构。

3. **编译模板实例（Instantiated Template Compilation）：** 在实例化阶段，编译器会根据特定的参数类型生成实际的类和函数定义，并进行编译。这相当于为每个实例化的模板生成了一个特定的类定义。

4. **链接阶段（Linking）：** 如果**实例化的模板**在多个源文件中被使用，链接器会将这些实例化后的代码进行链接，确保所有引用都能正确连接到它们的定义。

需要注意的是，C++的模板是一种**头文件实现的特性**，模板的声明和定义通常都包含在头文件中。这意味着模板的实例化和编译过程可能会在不同的源文件中进行，而链接阶段会将它们连接在一起。这也是为什么模板的定义和实现通常都放在头文件中的原因之一。

### 函数栈帧调用过程

在大多数计算机体系结构中，函数调用时会将相关的信息保存在栈上，这个过程被称为函数的“压栈”（Push）操作。这些保存的信息通常包括以下内容：

1. **返回地址：** 当函数调用结束后，程序需要知道从哪里继续执行。因此，函数调用前的指令地址（返回地址）会被保存在栈上，以便函数调用结束后返回到正确的位置继续执行。

2. **局部变量：** 函数内部的局部变量和临时变量会被保存在栈上。这样，在函数执行期间，这些变量可以在栈上分配内存，函数返回后会自动释放。

3. **调用者的状态：** 保存在栈上的信息可能还包括**一些寄存器的值，以及其他需要在函数调用结束后还原的状态。**

默认情况下，函数压栈的方式遵循以下步骤：

1. **保存返回地址：** 在函数调用前，调用指令的下一条指令地址（返回地址）会被保存在栈上。

2. **保存调用者状态：** 一些寄存器的值和其他状态信息会被保存在栈上，以便在函数调用结束后还原。

3. **分配局部变量空间：** 在栈上为函数的局部变量和临时变量分配空间。

4. **执行函数体：** 函数体内的代码被执行。

5. **释放局部变量空间：** 在函数调用结束后，局部变量占用的栈空间会被释放。

6. **还原调用者状态：** 之前保存的调用者状态会被还原，包括恢复寄存器的值等。

7. **跳回到返回地址：** 函数调用结束后，会从保存的返回地址处继续执行，即回到调用函数的地方。

这个过程可以确保在函数调用结束后，程序的执行状态恢复到调用前的状态，同时在函数内部可以方便地使用局部变量和临时变量。这种方式在不同的计算机体系结构和编程语言中可能有一些细微的差异，但总体思想是相似的。

### QQ微信涉及到的技术

QQ 和微信是两个非常流行的即时通讯和社交应用，它们的实现涉及多种技术和组件。以下是一些可能用于实现这些应用的关键技术：

1. **网络通信：** 实现实时通讯需要高效的网络通信机制。这可以涉及使用 TCP/IP 或 UDP 协议，WebSocket 技术以及长连接等，以确保消息的及时传输。

2. **服务器架构：** QQ 和微信需要庞大的服务器架构来支持海量用户。这可能包括负载均衡、分布式存储、数据库集群等，以确保系统的可伸缩性和稳定性。

3. **消息传递和推送：** 实时消息传递和推送是这些应用的核心。这可能涉及使用消息队列系统（如 RabbitMQ、Kafka）来处理消息分发，以及使用推送服务（如 APNs、Firebase Cloud Messaging）将消息推送到移动设备。

4. **实时聊天：** 实时聊天可能使用 Socket 技术，WebSocket 或其他实时通信框架来实现，以便用户可以实时地收发消息。

5. **多媒体处理：** 这些应用支持图片、视频、音频等多媒体内容的发送和接收。处理多媒体内容可能涉及图片和视频压缩、音频编解码等技术。

6. **用户身份验证和安全：** 用户身份验证是关键环节，使用密码、手机验证码、双因素认证等确保用户账户的安全。

7. **数据加密和隐私保护：** 保护用户聊天内容的隐私对于这类应用至关重要。数据加密技术可以确保聊天内容在传输和存储过程中得到保护。

8. **搜索和推荐算法：** 这些应用可能使用搜索和推荐算法来帮助用户找到好友、群组、内容等。

9. **实时位置共享：** 为了实现实时位置共享，可能会使用 GPS 技术和地图 API。

10. **社交功能：** 好友管理、朋友圈、群组聊天等社交功能需要强大的后端支持。

11. **移动开发：** QQ 和微信提供移动端应用，移动开发技术（如 Android、iOS）也是不可或缺的。

总之，实现 QQ 和微信这样的大型即时通讯和社交应用需要综合多种技术和组件，以提供稳定、安全、实时的通信体验。

### 介绍一下哈希

哈希表（Hash Table）是一种常见的数据结构，用于实现键-值（key-value）对的映射关系。它通过哈希函数将键映射到数组中的索引位置，从而实现**高效的**数据**查找和插入**操作。

哈希表的原理可以概括如下：

1. **哈希函数（Hash Function）：** 哈希表使用哈希函数将键转换成一个整数，这个整数就是数组的索引。好的哈希函数应该尽量均匀地将不同的键映射到不同的索引，以减少哈希冲突的可能性。

2. **数组（Array）：** 哈希表使用一个数组来存储键-值对。数组的每个位置称为“槽”（slot），每个槽对应一个索引。哈希函数将键映射到某个索引，然后将值存储在该索引对应的槽中。

3. **处理哈希冲突：** 哈希函数有可能将不同的键映射到**相同的索引**，这就是哈希冲突。为了解决冲突，哈希表采用不同的方法，如链地址法（Chaining）和开放地址法（Open Addressing）。链地址法在每个槽中维护一个链表，将具有相同哈希值的键-值对存储在同一个链表中。开放地址法则在发生冲突时，尝试在数组中的其他位置寻找空槽来存储键-值对。在查找时采用线性探测的方式查找,特殊情况下效率会较低.

4. **查找和插入操作：** 对于查找操作，哈希表使用哈希函数找到键对应的索引，然后在该索引对应的槽中搜索值。对于插入操作，哈希函数找到键对应的索引，然后将值存储在该索引对应的槽中。

哈希表的优点是**在平均情况下**，查找、插入和删除操作的时间复杂度都为O(1)。然而，在实际情况中，哈希冲突和选择适当的哈希函数也会影响哈希表的性能。因此，在设计和使用哈希表时，需要选择合适的哈希函数，并根据实际情况选择适当的解决冲突方法。

### 函数定义大数组的影响

在Linux操作系统中，函数内定义大数组可能会引发一些问题和考虑。这些问题主要与内存使用、栈溢出和性能等方面有关。

1. **栈溢出：** 在函数内部定义大数组可能导致栈溢出的风险。栈是用于存储**函数的局部变量和函数调用信息**的内存区域，它的大小是有限的。如果在函数内定义的大数组超过了栈的容量，就会发生栈溢出错误，导致程序崩溃。

2. **内存使用：** 函数内定义的数组通常会在栈上分配内存。栈上的内存分配速度相对较快，但也比堆上的内存分配受限。大数组可能占用大量栈空间，从而减少了可用的栈空间，可能**影响其他函数的调用和执行。**

3. **性能影响：** 在函数内定义大数组可**能会导致频繁的栈内存分配和释放操作**，这可能对性能产生影响。频繁的内存分配和释放操作**可能导致堆栈的碎片化**，增加了内存管理的开销。

为了避免上述问题，你可以考虑以下做法：

- 将大数组定义在函数外部或者使用动态内存分配（在堆上分配）。这可以避免栈溢出问题，并且更好地控制内存使用。
- 如果必须在函数内部定义数组，可以考虑使用`malloc`等动态内存分配函数，将数组分配在堆上。但请注意，在使用完毕后记得释放动态分配的内存，以防止内存泄漏。

总之，在函数内定义大数组可能会引发问题，因此需要根据程序的需求和性能要求来进行权衡和决策。

##### 大数组要定义在主函数外部的原因

全局变量在**静态存储区**内分配内存，而局部变量是在栈内分配内存空间的。C语言编写的程序会在运行期间创建一个堆栈段，用来保存函数的调用关系和局部变量。而在main函数内部定义大数组相当于在栈内需要一个很大的空间，会造成栈的溢出。因此，当我们需要定义一个极大的数组时，最好在main 函数外部定义这个大数组。

### 内核态用户态

内核态（Kernel Mode）和用户态（User Mode）是操作系统中的两种不同的执行级别，用于区分操作系统内核的执行和应用程序的执行。

1. **内核态（Kernel Mode）：** 内核态是操作系统内核执行的**特权级别**。在内核态下，操作系统内核可以直接访问硬件资源、执行特权指令以及执行敏感的操作，如修改页表、中断处理等。内核态具有最高的权限和控制权，因此操作系统内核在此模式下运行，可以管理和控制整个系统的资源。

2. **用户态（User Mode）：** 用户态是普通应用程序执行的权限级别。在用户态下，应用程序只能访问有限的资源，并且受到操作系统内核的保护，无法直接执行特权指令或者访问敏感的硬件资源。这种限制是为了确保应用程序的运行不会影响整个系统的稳定性和安全性。

在现代操作系统中，为了保障系统的安全和稳定，将内核态和用户态明确分离，并使用特权级别、硬件保护机制以及虚拟内存等手段进行管理。当应用程序需要执行某些特权操作或访问受限资源时，它必须通过系统调用（syscall）向操作系统内核发起请求，从用户态切换到内核态，让内核代表应用程序执行相应的操作。

切换从用户态到内核态是有一定开销的，因为涉及到上下文切换和硬件状态的变更。这也是为什么操作系统设计中需要权衡，尽量减少不必要的内核态切换，以提高系统的性能和效率。

### 信号量

信号量（Semaphore）是一种用于多线程和多进程编程中的同步机制，用于控制对共享资源的访问。它是一种计数器，用于管理多个线程或进程对共享资源的访问权限，从而避免竞争条件和资源冲突。

信号量通常有两种类型：

1. **二进制信号量（Binary Semaphore）：** 也称为互斥锁（Mutex），它只有两个状态：0 和 1。用于确保在给定时间内只有一个线程或进程可以访问共享资源，从而避免竞争条件。**二进制信号量经常用于保护临界区**，即在任何给定时间只允许一个线程执行的代码块。

2. **计数信号量（Counting Semaphore）：** 也称为通用信号量，它可以持有一个整数值，**代表资源的可用数量**。线程或进程可以请求获取一个或多个信号量，如果信号量的值大于等于请求的数量，则资源被分配给线程或进程。使用计数信号量可以控制多个线程或进程同时访问有限数量的共享资源。

信号量的主要操作包括：

- **初始化（Initialization）：** 在开始使用信号量之前，需要初始化它。对于二进制信号量，可以初始化为1表示资源可用；对于计数信号量，可以初始化为可用资源的数量。

- **等待（Wait）：** 也称为 P 操作。**sem_wait()**,线程或进程在尝试获取资源之前会执行等待操作。如果信号量的值大于零，它会减少信号量的值，并允许线程或进程继续执行。否则，线程或进程可能被阻塞，直到信号量的值大于零。

- **释放（Signal）：** 也称为 V 操作。**sem_post()**,线程或进程在使用完资源后会执行释放操作。这会增加信号量的值，表示资源已经可用。

信号量是一种强大的同步机制，可以用于解决多线程或多进程编程中的各种并发问题，如资源竞争、死锁和饥饿等。然而，使用不当可能会导致问题，例如死锁或过度竞争，因此在设计并发程序时需要小心谨慎地使用信号量。

### 流量控制的机制

发送方发送窗口的实际大小由流量控制和拥塞控制共同决定，流量控制窗口rwnd由**接收方在TCP报文段首部窗口字段**提供，而拥塞控制窗口由发送方对当前网络环境的预估，结合慢开始和拥塞避免或者更优算法快传和快恢复算法来进行拥塞控制。最终发送方实际的发送窗口大小是由rwnd和cwnd中较小的那一个确定的。

流量控制是网络通信中的一个重要概念，它指的是在发送方和接收方之间调节数据传输速率的机制，以避免网络拥塞和资源浪费。以下是一些常见的流量控制机制：

1. **滑动窗口协议（Sliding Window Protocol）：** 这是一种广泛使用的流量控制机制。发送方维护一个发送窗口，其中包含允许发送的未确认数据包。接收方维护一个接收窗口，指示它可以接收的未确认数据包。发送方根据接收方的确认来调整发送窗口的大小，以控制数据的传输速率。
2. **停-等协议（Stop-and-Wait Protocol）：** 这是一种简单的流量控制机制，发送方发送一个数据包，然后等待接收方的确认。只有在收到确认后，发送方才会发送下一个数据包。这种机制可以避免数据包的丢失，但效率较低。
3. **Selective Repeat 协议：** 这是一种滑动窗口协议的变种，允许发送方发送多个数据包而不需要等待所有数据包都被确认。接收方会缓存已接收的数据包，然后选择性地确认缺失的数据包，从而提高了传输的效率。
4. **拥塞窗口控制（Congestion Window Control）：** 与流量控制不同，拥塞窗口控制主要关注网络拥塞的情况。发送方通过调整发送速率来避免拥塞的发生。拥塞窗口控制会根据网络的拥塞程度来动态调整发送窗口的大小，从而控制数据包的发送速率。

这些流量控制机制可以根据不同的应用需求和网络环境来选择和实现。在设计网络通信协议时，合适的流量控制机制可以确保数据的有效传输，并最大限度地减少网络拥塞和资源浪费。

### 断点续传

##### 定义

断点续传是一种网络传输技术，允许在网络传输过程中出现中断后，能够从中断处继续传输而不必从头开始。这在大文件传输等场景中非常有用，因为它能够节省时间和带宽，减少数据的重复传输。

[断点续传](https://so.csdn.net/so/search?q=断点续传&spm=1001.2101.3001.7020)：指的是在上传/下载时，将任务（一个文件或压缩包）人为的**划分为几个部分**，**每一个部分采用一个线程进行上传/下载**，如果碰到网络故障，可以从已经上传/下载的部分开始**继续**上传/下载未完成的部分，而没有必要从头开始上传/下载。可以节省时间，提高速度。分片之后的文件都需要有唯一的标识.

##### 用途

有时用户上传/下载文件需要历时数小时，万一线路中断，不具备断点续传的 HTTP/FTP 服务器或下载软件就只能从头重传，比较好的 HTTP/FTP 服务器或下载软件具有断点续传能力，允许用户从上传/下载断线的地方继续传送，这样大大减少了用户的烦恼。

##### 步骤

以下是一般情况下实现断点续传的步骤：

1. **文件分片：** 首先，将要传输的大文件分成多个小片段（或块），每个块的大小可以根据需求设定。

2. **传输和保存：** 在传输文件时，每个块都会被逐个传输到目标服务器。*服务器在接收到一个块后，将其保存在一个临时位置*，而不是立即将其整合到目标文件中。

3. **记录状态：** 为了实现断点续传，*必须记录每个成功传输的块的状态*，包括**块的序号**、大小和位置等信息。这些信息可以保存在服务器端的数据库或者文件中。

4. **断点处理：** 如果传输过程中出现中断，**客户端可以通过查询服务器上的记录来确定断点的位置**。然后，客户端可以发送一个请求，从断点位置继续传输未传输的块。

5. **续传：** 服务器在接收到续传请求后，**根据断点位置**，从临时存储中找到未传输的块，然后将这些块传输给客户端。客户端接收到这些块后，将它们按顺序组合到已传输的块后面。

6. **合并文件：** 在客户端传输完所有块后，客户端和服务器都知道所有块已经传输完成。这时，服务器可以将临时存储的所有块合并成完整的文件，然后通知客户端传输已成功完成。

需要注意的是，实现断点续传涉及到客户端和服务器之间的协调工作。客户端负责检测中断并发送续传请求，服务器负责保存未传输的块和提供这些块的下载。此外，还需要处理各种异常情况，如块的丢失、损坏等。

#### Range & Content-Range

HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容，这为**并行下载**以及**断点续传**提供了技术支持。它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range。

##### Range

用于请求头中，**指定第一个字节的位置和最后一个字节的位置**，一般格式：

> Range:(unit=first byte pos)-[last byte pos]
>
> Range 头部的格式有以下几种情况：
>
> Range: bytes=0-499 表示第 0-499 字节范围的内容
>
> Range: bytes=500-999 表示第 500-999 字节范围的内容
>
> Range: bytes=-500 表示最后 500 字节的内容
>
> Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容
>
> Range: bytes=0-0,-1 表示第一个和最后一个字节
>
> Range: bytes=500-600,601-999 同时指定几个范围

##### Content-Range

用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回**当前接受的范围和文件总大小**。一般格式：

> Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth]
>
> 例如：
>
> Content-Range: bytes 0-499/22400
>
> 0－499 是指当前发送的数据的范围，而 22400 则是文件的总大小。
>
> 而在响应完成后，返回的响应头内容也不同：
>
> HTTP/1.1 200 Ok（不使用断点续传方式）
>
> HTTP/1.1 206 Partial Content（使用断点续传方式）