//给定一个整数数组 A，坡是元组(i, j)，其中  i < j 且 A[i] <= A[j]。这样的坡的宽度为 j - i
//找出 A 中的坡的最大宽度，如果不存在，返回 0.只是要求元组,并没有要求连续.
//https://leetcode.cn/problems/maximum-width-ramp/
// 
//从左往右遍历,单调栈维护着所有以index为开头的坡的可能性,
// 1. 单调栈中顺序问题
// 单调栈只保存可能以他开头的坡度的可能性,所以栈中应该是保存小压大的顺序,
// 每一个都可能是以他为开头的坡度,
// 如果是大压小,那么因为有更小值的存在,小的那个开头的坡度一定比大的那个更宽,所以没有存大的那个必要了
// 所以,为了保证单调栈中存放的都是有意义的,所以是小压大,单调递减.
// 
// 2. i,j,i<j,i位置先入栈
// 考虑到入栈时相等值的出现,[i]==[j],如果之后遇到较小值,得到的宽度较大值应该是以i为开头的,
//所以i位置完全没有弹出的必要,所以应该是j>=i时,j++;j<i时,弹出i.
// 单调栈遍历得到递减数组,维护从底到顶,严格递减的数组
// 3. 弹出,从后往前依次讨论栈顶元素, 
// 从后往前遍历,寻找弹出栈,记录坡度宽度的可能,
// https://www.bilibili.com/video/BV1GH4y1D7TB?t=725.1
// if end > top(),不一定比下面的元素更大,所以记录ans,弹出top().此时以top()开头的一定是最宽的,
// else if end<top(),肯定比下面的元素更小,不满足条件,end--
// 
// 错误思路:尝试从左到右一遍走压入和弹出
//如果j位置大于i位置,说明以i为开头的坡度的长度一定大于以j位置开头的坡的宽度,所以j++
//如果j位置小于i位置,说明以i位置开头的坡度已经到头了,弹出i位置,记录此时i位置的长度,j-i,
// 但是此时会出现问题,因为数组时无序的,此时j位置比i位置小,你弹出记录i坡度值,可能在后面还有比i位置小的存在,
// 那你此时记录的就会出现问题,所以弹出这么做是存在问题的.
//
#include<iostream>
#include<vector>
using namespace std;
class Solution
{
public:
    int maxWidthRamp(vector<int>& nums)
    {
        int n = nums.size();
        vector<int>st(n);//单调栈中记录的永远都是数组下标
        int r = 1;//代表0下标已经进栈
        for (int i = 1; i < n; i++)
        {
            if (nums[i] < nums[st[r - 1]])
                st[r++] = i;
        }
        int ans = 0;
        for (int i = n - 1; i >= 0; i--)
        {
            while (r > 0 && nums[i] >= nums[st[r-1]])
            {
                ans = max(ans, i - st[--r]);
            }
        }
        return ans;
    }
};