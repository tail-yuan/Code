#### SSL

SSL (Secure Sockets Layer) 是一种用于保护网络通信安全的协议。它的继任者是TLS (Transport Layer Security)，因此现在通常使用的是TLS协议（如TLS 1.2或TLS 1.3）。SSL/TLS协议的目标是在通信过程中确保数据的机密性、完整性和身份验证，从而防止数据被窃听、篡改或伪装。

SSL/TLS协议的主要功能和组成部分包括：

1. **加密与解密**：SSL/TLS使用加密算法对传输的数据进行加密，确保只有合法的接收方能够解密并读取数据。常见的加密算法包括**对称加密**（如AES、3DES）和**非对称加密**（如RSA、ECC）。

2. **数据完整性保护**：SSL/TLS使用消息认证码（MAC）或HMAC（哈希消息认证码）来验证数据是否在传输过程中被篡改。这样**接收方可以确保接收到的数据没有被修改**。

3. **身份验证**：SSL/TLS可以对**通信双方**进行身份验证，**确保通信双方的身份是可信的**。服务器的身份认证通常使用数字证书，而客户端身份认证可以是可选的，如客户端证书认证或基于用户名密码的认证。

4. **协商加密算法和密钥**：在建立连接时，SSL/TLS使用握手协议进行协商，确定要使用的加密算法、密钥长度以及其他相关参数。协商过程中也会验证服务器的身份和客户端的选择。

5. **会话管理**：SSL/TLS支持会话重用和会话恢复，以减少握手过程的开销，提高性能。

6. **支持HTTPS**：HTTPS（HTTP over SSL/TLS）是基于SSL/TLS的安全HTTP协议，常用于保护Web通信安全，是加密传输数据的标准协议。

**SSL/TLS协议主要在传输层工作**，应用层的数据在传输**前被SSL/TLS协议加密**，在接收方得到解密后传递给应用层处理。**它的设计目标是在不安全的网络环境中提供保密性和数据完整性，为网络通信提供安全性的基础**。

总结起来，SSL/TLS是一种通信安全协议，用于在通信双方之间建立加密、认证和完整性保护的连接，确保数据在传输过程中的安全性。它广泛应用于Web服务器和客户端之间的安全通信，以及其他需要保护数据安全的场景。

#### http和https的区别

SSL/TLS与HTTP和HTTPS之间有着密切的关系，它们是网络通信安全性的关键组成部分。

HTTP（Hypertext Transfer Protocol）是一种用于在Web浏览器和Web服务器之间传输数据的协议。**它是一种明文协议**，意味着数据在传输过程中是以明文形式传递的，容易被窃听和篡改。这就带来了安全风险，尤其是对于敏感数据（如登录凭据、支付信息等）的传输。

为了解决HTTP的安全问题，引入了HTTPS（HTTP Secure）。**HTTPS是HTTP协议的安全版本**，它在HTTP的基础上加入了SSL/TLS协议来提供数据加密和身份验证，从而保护数据的机密性和完整性。

主要的区别点如下：

1. **数据传输的安全性：** 在HTTP中，数据以明文形式传输，容易被窃听和篡改。而在HTTPS中，数据在传输前会使用SSL/TLS协议进行加密，确保数据在传输过程中是安全的，不易被窃听或篡改。

2. **端口号：** **HTTP使用端口号80进行通信，而HTTPS使用端口号443进行安全通信。**

3. **URL前缀：** 在浏览器中，HTTP的URL以 "http://" 开头，而HTTPS的URL以 "https://" 开头。

4. **证书验证：** HTTPS连接使用**数字证书来验证服务器的身份**。这个数字证书由经过信任的证书颁发机构（CA，Certificate Authority）签发，确保连接到的服务器是真实的，而不是被恶意伪装的。

5. **性能开销：** HTTPS由于使用了加密和解密过程，会增加一定的性能开销，使得相同数据的传输速度较HTTP略慢。但随着计算能力的提高和硬件支持，这种性能差异正在逐渐减小。

总之，HTTPS是在HTTP基础上加入了SSL/TLS协议来提供数据的加密和身份验证，以确保通信过程中的安全性。因此，当涉及到敏感数据传输或安全性要求较高的场景时，使用HTTPS是必要的选择。

#### 观察者模式

观察者模式（Observer Pattern）是一种软件设计模式，属于行为型模式之一。它用于建立对象之间的一种**一对多依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都将得到通知并自动更新**。观察者模式的核心思想是**解耦对象之间的关联，使得它们可以独立地交互和改变**。

在观察者模式中，有两种主要角色：

1. Subject（主题）：也称为被观察者，它持有一个观察者列表并提供添加、删除和通知观察者的方法。
2. Observer（观察者）：观察者通过注册到主题来接收通知，并**在主题状态改变时执行相应的更新操作。**

`getState()`函数是一个虚函数，用于获取具体主题（ConcreteSubject）对象的状态。观察者模式的核心目标是在主题状态改变时通知所有的观察者，并让观察者能够获取主题的最新状态。

在具体主题类 `ConcreteSubject` 中，`getState()` 函数被定义为纯虚函数（pure virtual function），这意味着在 `ConcreteSubject` 中并没有给出具体的实现，而是将其留给派生类实现。因为不同的具体主题可能有不同的状态表示和获取方式，所以这里将其定义为纯虚函数，让派生类必须实现它。

在这个简单的示例中，`ConcreteSubject` 并没有包含实际的状态数据，而是使用一个简单的 `int` 类型变量 `state` 来模拟状态。`setState()` 函数用于设置主题的状态，并在状态改变后通知所有观察者。`getState()` 函数则用于获取当前的状态值。

如果在实际应用中，`ConcreteSubject` 类表示一个更复杂的对象，可能包含多个状态字段，那么 `getState()` 函数就会根据具体情况来获取并返回主题的状态信息。每个观察者通过调用 `getState()` 函数来获取最新的主题状态，然后根据状态的改变来做出相应的响应或处理。

```C++
#include <iostream>
#include <vector>

// 前向声明
class Observer;

// 主题类
class Subject {
public:
    void addObserver(Observer* observer) {
        observers.push_back(observer);
    }

    void removeObserver(Observer* observer) {
        // 在实际应用中可能需要更复杂的逻辑来查找并删除观察者
        auto it = std::find(observers.begin(), observers.end(), observer);
        if (it != observers.end()) {
            observers.erase(it);
        }
    }

    void notifyObservers() {
        for (Observer* observer : observers) {
            observer->update();
        }
    }

    virtual int getState() const = 0;

protected:
    std::vector<Observer*> observers;
};

// 观察者类
class Observer {
public:
    virtual void update() = 0;
};

// 具体主题类
class ConcreteSubject : public Subject {
public:
    void setState(int state) {
        this->state = state;
        notifyObservers();
    }

    int getState() const override {
        return state;
    }

private:
    int state;
};

// 具体观察者类
class ConcreteObserver : public Observer {
public:
    ConcreteObserver(ConcreteSubject* subject) : subject(subject) {}

    void update() override {
        int state = subject->getState();
        std::cout << "Observer: Received state update. New state is " << state << std::endl;
    }

private:
    ConcreteSubject* subject;
};

int main() {
    ConcreteSubject subject;

    ConcreteObserver observer1(&subject);
    ConcreteObserver observer2(&subject);

    subject.addObserver(&observer1);
    subject.addObserver(&observer2);

    subject.setState(123);

    subject.removeObserver(&observer1);

    subject.setState(456);

    return 0;
```

#### 死锁

##### 产生条件

1. 互斥条件

   至少有一个资源必须处于互斥状态，即一次只能由一个进程或线程使用。这意味着其他进程或线程必须等待资源释放才能继续执行。

2. 占有并等待条件

   进程或线程必须同时占有至少一个资源并且**等待获取其他进程或线程占有的资源**。即，一个进程在等待其他进程释放资源的同时，自己占有了一些资源。

3. 不可剥夺

   资源不能被强制性地从一个进程或线程中剥夺，只能由占有该资源的进程或线程自愿释放。

4. 循环等待条件

   存在一个进程（线程）的**资源请求链**，使得**每个进程都在等待下一个进程所持有的资源**。这样就形成了一个闭环，使得每个进程都无法继续执行。

##### 避免方式

1. 破坏互斥条件：尽量避免使用互斥资源，或者**使用其他同步机制来代替互斥锁。**

2. 破坏占有和等待条件：实行资源**预分配策略**，进程在开始执行前，**需要一次性请求所有需要的资源**，保证在执行过程中不再申请其他资源。

3. 破坏不可剥夺条件：**引入资源抢占机制**，允许系统在适当的时候剥夺进程持有的资源。

4. 破坏循环等待条件：对资源进行排序，并按照固定的顺序请求资源，避免出现循环等待的情况。

   当涉及到循环等待条件时，可以通过以下家庭生活中的例子来更好地理解。

   **例子：家庭成员之间的资源竞争**

   假设一个家庭有父亲、母亲、儿子和女儿，家中有两个资源：电视遥控器和电脑。每个家庭成员都喜欢看电视和使用电脑来完成各自的任务。

   现在，让我们考虑以下情况：

   1. 儿子拿着电视遥控器，正在看电视，同时他想要使用电脑玩游戏。
   2. 女儿正在使用电脑，她需要电视遥控器来切换频道观看电视。

   在这个家庭中，儿子拿着电视遥控器等待电脑空闲，而女儿拿着电脑等待电视遥控器空闲。这就形成了循环等待条件：

   **儿子等待电脑 -> 女儿占有电脑，女儿等待电视遥控器 -> 父亲占有电视遥控器，等待电脑 -> 儿子占有电脑，形成了一个循环。**

   在这种情况下，由于每个家庭成员都在等待其他人释放资源，他们无法继续自己的任务，从而导致循环等待和资源无法有效利用，类似于计算机系统中的死锁现象。要解决这种问题，家庭成员可以相互协调，交换资源，或者制定一些规则来合理使用资源，避免形成循环等待条件。

通过合理的资源分配和管理，可以有效地预防死锁的发生。

##### 生活例子

**例子1：交通死锁**

想象一个交叉路口，其中有两条道路，分别是A路和B路。现在，一辆车从A路尝试通过交叉路口前往B路，同时，另一辆车正从B路尝试通过交叉路口前往A路。由于交叉路口只能容纳一辆车通过，因此这两辆车会互相等待，导致交通死锁。每辆车都需要对方先通过，但对方也在等待，从而导致双方无法继续前进。

**例子2：资源共享死锁**

想象一个家庭，有一个共享的电视遥控器和一台游戏主机。现在，兄弟姐妹A和B都想要使用电视遥控器来看电视，但只有一台遥控器。同时，他们都想要使用游戏主机来玩游戏，但也只有一台主机。于是，A拿着遥控器等待主机空闲，而B拿着主机等待遥控器空闲。由于只有一个资源可以同时被一个人占用，他们互相等待对方释放资源，导致资源共享死锁。

##### 开发场景死锁例子

当讨论死锁时，可以通过一些简单的例子来说明死锁产生的条件。以下是两个基本的例子：

**例子1：两个进程相互竞争两个资源**

假设有两个进程：进程A和进程B，同时竞争两个资源：资源X和资源Y。这两个进程执行的代码如下：

**进程A代码：**
```C++
// 进程A开始执行
lock(X); // 锁定资源X
// 假设在这里发生了上下文切换，进程B开始执行
lock(Y); // 进程A试图锁定资源Y，但被进程B占有，进程A等待
// 进程B释放资源Y
unlock(Y);
// 进程B结束执行
```

**进程B代码：**
```c
// 进程B开始执行
lock(Y); // 锁定资源Y
// 假设在这里发生了上下文切换，进程A开始执行
lock(X); // 进程B试图锁定资源X，但被进程A占有，进程B等待
// 进程A释放资源X
unlock(X);
// 进程A结束执行
```

在这个例子中，进程A和进程B同时竞争资源X和资源Y，但由于互斥条件，一次只能有一个进程占有一个资源。**当进程A锁定资源X后，进程B等待资源X的释放，而进程B占有了资源Y，进程A等待资源Y的释放**。这样就形成了循环等待条件，导致死锁的发生。

**例子2：多个进程竞争有限数量的资源**

假设有三个进程：进程P1、进程P2和进程P3，以及两个资源：资源A和资源B。这三个进程执行的代码如下：

**进程P1代码：**
```C
// 进程P1开始执行
lock(A); // 锁定资源A
lock(B); // 锁定资源B
// 执行任务...
unlock(B); // 释放资源B
unlock(A); // 释放资源A
// 进程P1结束执行
```

**进程P2代码：**
```C
// 进程P2开始执行
lock(B); // 锁定资源B
lock(A); // 锁定资源A
// 执行任务...
unlock(A); // 释放资源A
unlock(B); // 释放资源B
// 进程P2结束执行
```

**进程P3代码：**
```C
// 进程P3开始执行
lock(A); // 锁定资源A
// 进程P3试图锁定资源B，但被进程P1占有，进程P3等待
// 进程P1释放资源B
lock(B); // 锁定资源B
// 执行任务...
unlock(B); // 释放资源B
unlock(A); // 释放资源A
// 进程P3结束执行
```

在这个例子中，进程P1和进程P2都可以成功地执行并释放资源，但进程P3在执行过程中**由于等待资源B而被阻塞**，而资源B被进程P1占有。进程P1需要资源A和B来完成任务，而进程P2需要资源A和B，这样就形成了**占有和等待条件**。进程P3等待进程P1释放资源B，同时进程P1又在等待进程P3释放资源A，这样就形成了循环等待条件，导致死锁的发生。
