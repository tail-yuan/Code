#### I/O 多路复用

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，**可以监视多个文件描述符**，一旦某个描述符就绪（一般是读就绪或者写就绪，还有异常就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们**都需要在读写事件就绪后自己负责进行读写**，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现**会负责把数据从内核拷贝到用户空间**。

#### static关键字的作用

- static修饰全局变量,该变量只能在本文件内被访问,不能被其他文件直接访问.

- 如果函数被static修饰,该函数只能在本文件内访问.会出现链接时报错.

- static修饰局部变量,更改局部变量的生命周期,把临时的改成全局的.但是作用域仍然没有变,还是在局部代码块中.初始化的动作,只会初始化一次

#### C和C++ 的区别

- C++是面向对象的编程语言,C语言是面向过程的语言.
- C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库更灵活、更通用 .
- C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try-catch等等  

#### C++中 struct 和 class 的区别  

- struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的  
- class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数  
- 在继承关系中，struct 默认是公有继承，而 class 是私有继承；  

#### 从10亿个数中选取1000个最大最小数

TopK问题,小顶堆的堆顶元素是整个堆中最小的，后续数据如果比堆顶还小，那么由于堆中本来就有N个数据，那么自然就不符合条件，可以丢弃了；如果后续数据比堆顶大，那么就说明这个数可能在Top N中，起码当前堆顶元素肯定就不在Top N中了，所以用这个数替换掉当前堆顶，由于这个数不一定是整个堆中最小的，所以还要调整堆，使堆继续保持堆的特性，以便继续判断后面的数据。这个过程遍历完了数据以后，堆中的元素就是要找的Top N了。

#### [静态编译和动态编译](https://blog.csdn.net/weixin_38907560/article/details/81478981)

链接分为静态链接和动态链接。

> - 静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。
> - 动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。  

**静态编译**:编译器在编译可执行文件时，把需要用到的对应动态链接库(.so或.ilb)中的部分提取出来，**链接到可执行文件中去**，使可执行文件在运行时不需要依赖于动态链接库.(库在可执行程序中)

静态lib将导出声明和实现都放在lib中。编译后所有代码都嵌入到宿主程序。

**动态编译**: 动态编译的可执行文件需要附带一个的动态链接库，在执行时，需要调用其对应动态链接库中的命令.(库和可执行程序并列共存)

动态lib相当于一个.h文件，是对实现部分（.dll文件）的导出部分的声明。编译后只是将导出声明部分编译到宿主程序中，运行时候需要相应的dll文件支持。

##### 动态编译优点

缩小了可执行文件本身的体积.

加快连接速度节省系统资源.

##### 动态编译缺点

如果其他计算机没有安装对应运行库,动态编译则不能运行可执行文件

哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库.

#### STL六大组件

容器 算法 仿函数 迭代器 适配器 空间配置器

#### 红黑树vs平衡二叉搜索树(AVL树)

红黑树是近似平衡,AVL树是高度平衡,但是高度平衡的代价是经过了很多次的旋转来维护的,红黑树不需要进行那么多次的旋转.效率上红黑树会劣势,但是内存搜索上是差不多的所以综合来说红黑树更优.

#### 死锁场景

两个人喝水,一个人拿着水壶不放,一个人拿着水杯不放手,这样谁都喝不到水完成不了把水倒到水杯喝水的操作.

#### 进程和线程的区别

进程是系统分配资源和调度的基本单位.线程是cpu调度和分派的最小基本单位.

* 一个进程可以包含至少一个线程.
* 线程是轻量级进程,切换速度和执行效率更高更快.

* 同一个进程下，一个线程的挂掉，会导致整个进程的挂掉，而进程之间不会相互影响.
* 进程对资源的保护要求高，而线程要求不高.
* 一个进程中可以并发多个线程，每个线程执行不同的任务 
* 拥有资源不同：每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源。
* **所属线程的栈区、程序计数器、栈指针以及函数运行使用的寄存器是线程私有的**。

> 我们可以打个比方:进程相当于某一个大型项目，世界上可能有人同时在做这个项目，有其独特的方式；而线程就相当于这个项目下的一些程序员，多个程序员去完成这一个项目肯定要比一个人完成快的多，也就是能在同一时间操作.

#### TCP报头及各自作用

* 四位首部长度,20字节报头,所以是5 0101
* 32位确认序号,基于确认应答机制,通过一条信息确认以前的信息已经被接受.
* 32位序号:保证按序到达,因为接受的时候可能是乱序的.

为什么要分开?因为TCP是一个全双工的通信协议.双方都需要保证可靠性

* 16位窗口大小:tcp内部自带发送缓冲区和接收缓冲区,实现流量控制.因为缓冲区+16位窗口大小,才能根据OS的反馈实现发送多少的控制,所以才叫传输控制协议.
* 16位目的端口和16位源端口
* 6个标记位:ACK(请求标记位)SYN(连接建立确认,之后进行三次握手)RST(重发一遍呗)PSH(让对端应用层快点接收数据)URG(标记想让某些数据插队优先处理)Fin(分手吧,断开连接请求)

#### TCP有哪些保证可靠性的方式?

超时重传,确认应答机制(连接时可靠)

#### 用于提升效率

流量控制(接收能力),延时应答,捎带应答.

#### 为什么是三次握手?

* 确认双方主机是否健康
* 验证全双工,是能看到双方收发能力的最小次数
* 如果1次两次就可以建立连接,容易收到攻击,SYN洪水.

#### TIME_WAIT状态

主动断开连接的一方先进入TIME_WAIT 状态.

MSL,报文最大传送时间,报文在网络中的最长生存时间,一般是2*MSL.为什么?

* 保证历史数据的消散或被对方接收,没有新的数据再产生,正好一发一收.
* 尽量保证最后一个ACK被对面收到了.

![image-20230331120937198](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230331120937198.png)

after the Active Closer sends the last ACK (in response to the Passive Closer's FIN), it enters the TIME_WAIT state.

#### MySQL四大属性

ACID

原子性,一致性,隔离性,持久性.

