### 协议

![image-20230919183458779](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230919183458779.png)

### 长连接短连接

短连接和长连接（也称为持久连接或保持连接）是在网络通信中的两种不同的连接管理方式。

**短连接：**
短连接是指在完成一次通信后，即刻关闭连接的方式。每次通信都需要建立连接、传输数据、关闭连接，这样的连接方式通常用于一次性的请求-响应场景，如网页浏览。在短连接中，服务器不会保持连接状态，每次请求都需要重新建立连接，因此会增加连接建立和断开的开销。

**长连接（Keep-Alive）：**
长连接是指在一次通信结束后，保持连接状态，继续用于后续的通信。**在长连接中，客户端和服务器之间的连接会一直保持开启，可以在多次通信中重复使用同一个连接**。这样可以避免频繁地进行连接的建立和断开，减少了通信的开销。长连接通常用于需要多次交互的场景，**如实时通讯、即时消息**等。

**如何区分短连接和长连接：**
在通信过程中，短连接和长连接可以通过连接的持续时间来区分：

- **短连接：** 连接在一次通信结束后立即关闭，每次通信都需要重新建立连接。
- **长连接：** 连接在一次通信结束后保持开启状态，可以用于后续的多次通信。

在 HTTP 协议中，可以使用 `Connection` 头字段来区分短连接和长连接：

- `Connection: close`：表示使用短连接，通信结束后立即关闭连接。
- `Connection: keep-alive`：表示使用长连接，连接会保持开启状态。

在一些网络协议中，默认情况下可能是短连接，需要明确指定使用长连接来实现。

总之，短连接和长连接都有各自适用的场景，需要根据实际需求来选择合适的连接方式。

### HTTP HTTPS区别

- HTTPS 协议需要申请证书.
- HTTP 和 HTTPS 使用端口不一样，前者是80，后者是443
- HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的.
- HTTPS 可以有效的防止运营商劫持.

#### HTTP常见请求方法

HTTP（Hypertext Transfer Protocol）是一种用于传输在Web上的数据的协议。常见的HTTP请求方法（HTTP request methods）包括以下几种：

1. **GET**: 用于从服务器获取数据。它在请求的URL中指定资源，服务器将响应返回给客户端。这是最常见的HTTP请求方法。
2. **POST**: 用于向服务器提交数据，通常用于创建新的资源。请求的数据包含在请求体中。
3. **PUT**: 用于更新服务器上的资源，或者在资源不存在时创建新资源。类似于POST，但要求在请求中包含完整的更新数据。
4. **PATCH**: 用于部分更新资源。与PUT类似，但是它只需要在请求中发送需要修改的部分数据。
5. **DELETE**: 用于从服务器删除资源。
6. **HEAD**: 类似于GET请求，但服务器只返回响应头部分，不返回实际数据主体。通常用于获取资源的元数据而无需实际内容。
7. **OPTIONS**: 查询服务器支持的**HTTP方法**和其他通信选项。服务器在响应中返回支持的方法列表等信息。
8. **CONNECT**: 用于将客户端连接转换为网络隧道，通常用于代理服务器。

这些HTTP请求方法允许客户端与服务器之间进行不同类型的交互，例如获取资源、发送数据、更新资源等。每个请求方法都在HTTP头部的"Method"字段中指定。

#### HTTP与TCP

1. HTTP 协议是应用层协议，主要解决如何包装数据，是基于TCP连接的。TCP/IP 协议是传输层协议，主要解决数据在网路中如何传输的问题。

2. HTTP协议是获取地址，传递数据的一种基于请求与响应模式的应用层的协议。而TCP是服务器和客户端可以互相发送消息的交互模式。服务器主动可以推送消息给客户端。

3. Http就是在每次请求完成后就把TCP连接关了，所以是短连接。TCP是长连接。

TCP是HTTP进行端对端的数据交互时的数据请求方式；HTTP是TCP进行虚拟线路连接时获得服务端位置--端口号的来源。

HTTP是在TCP之上，它负责在发送端“生成针对目标Web服务器的HTTP请求报文”和在接收端“对Web服务器请求的内容进行处理”。



### HTTP常见Header![](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230815092121982.png)

- Content-Type

- Content-Length: 用于确定报文长度

- Host: 你要访问的那台主机.

- User-Agent：声明用户的OS和浏览器版本信息。

- referer: 当前页面是从哪个页面跳转过来的。

- Location: 搭配3xx的状态码使用,用于重定向.

- Set-Cookie: cookie和session

- Connetion: keep-alive长短连接

HTTP协议响应头是在HTTP响应中用于传递附加信息和控制缓存行为的字段。以下是一些常见的HTTP协议响应头：

1. **Content-Type**：指定**响应主体的媒体类型**（例如：text/html、application/json等）和字符集。
2. **Content-Length**：指定响应主体的长度，以字节为单位。
3. **Expires**：指定响应过期的日期和时间，用于缓存控制。
4. **Last-Modified**：指定资源的最后修改时间，用于缓存验证。
5. **Location**：用于**重定向响应，指定新的资源位置。**
6. **Set-Cookie**：设置响应中的Cookie信息，用于在客户端保存状态。
7. **Server**：指定服务器的名称和版本信息。
8. **Allow**：指定支持的HTTP方法，例如GET、POST、PUT、DELETE等。

以上是一些常见的HTTP协议响应头字段，它们可以**帮助客户端和服务器之间进行信息传递、缓存控制和安全性设置**。在编程和服务器配置中，正确使用这些响应头是非常重要的，可以提高Web应用程序的性能、安全性和用户体验。

#### http中缓存

HTTP协议中与缓存相关的字段通常包括以下几个：

1. **Cache-Control：** Cache-Control头字段用于**定义缓存策略**，控制响应在客户端和代理服务器之间的缓存行为。它包含了多个指令，如"max-age"（缓存有效时间）、"no-cache"（不缓存响应）和"no-store"（不存储响应），用于控制缓存的行为。

2. **Expires：** Expires头字段**指定响应的到期时间**，即响应将在此时间之后被视为过期，需要重新请求。这个字段已经不再被推荐使用，而Cache-Control的"max-age"指令通常更常见。

3. **Last-Modified 和 If-Modified-Since：** Last-Modified头字段**表示资源的最后修改时间**，而If-Modified-Since头字段用于在客户端发送请求时，将上次响应中的Last-Modified时间发送给服务器，以检查资源是否已经修改。**如果资源在服务器端未被修改，服务器可以返回一个304 Not Modified响应，告知客户端使用缓存。**

4. **ETag 和 If-None-Match：** ETag头字段是资源的唯一标识符，**用于判断资源是否已经修改**。客户端可以在请求中包含If-None-Match头字段，将上次响应中的ETag值发送给服务器，以请求资源的状态。如果资源的ETag值与客户端发送的匹配，服务器可以返回一个304 Not Modified响应。

这些HTTP头字段允许服务器和客户端在通信过程中管理缓存，以提高性能并减少不必要的网络流量。通过合理设置这些字段，可以控制缓存的行为，确保客户端获取最新的内容，同时减少了服务器的负载和提高了用户体验。

### HTTP请求方法

根据 HTTP 标准，HTTP 请求可以使用多种请求方法。

HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。

HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法

| 序号 | 方法    | 描述                                                         |
| :--- | :------ | :----------------------------------------------------------- |
| 1    | GET     | 请求指定的页面信息，并返回实体主体。                         |
| 2    | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3    | POST    | 向**指定资源提交数据,进行处理请求**（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致**新的资源的建立**和/或**已有资源的修改**。 |
| 4    | PUT     | 从客户端向服务器传送的数据**取代**指定的文档的内容。         |
| 5    | DELETE  | 请求服务器删除指定的页面。                                   |
| 6    | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| 7    | OPTIONS | 允许客户端查看服务器的性能。                                 |
| 8    | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| 9    | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

### HTTP各版本特性

#### HTTP 0.9

HTTP 0.9 是一个最古老的版本

- 只支持`GET`请求方式：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息
- 没有请求头概念：所以不能在请求中指定版本号，服务端也只具有返回 HTML字符串的能力
- 服务端相响应之后，立即关闭TCP连接

#### HTTP 1.0

随着 HTTP 1.0 的发布，这个版本:

- 请求方式新增了POST，DELETE，PUT，HEADER等方式
- 增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)
- 扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输

在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。

##### 特性

- 无状态：服务器不跟踪不记录请求过的状态.使用session cookie可以解决
- 无连接：浏览器每次请求都需要建立tcp连接
  - 无法复用连接
    每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低
  - 队头阻塞
    HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的.

#### HTTP 1.1

- 长连接：新增Connection字段，可以设置keep-alive值保持连接不断开.

  * HTTP 1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据

- 管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回.

  * 基于长连接的基础，我们先看没有管道化请求响应：

  tcp没有断开，用的同一个通道

  ```
  复制代码请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3
  ```

  管道化的请求响应：

  ```
  复制代码请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
  ```

  即使服务器先准备好响应2,也是按照请求顺序先返回响应1

  虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题

- 缓存处理：新增字段cache-control

  - 当浏览器请求资源时，先看是否有缓存的资源，

    如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。 

    通过设置字段cache-control来控制缓存。

- 断点传输

  - 在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率

#### HTTP 2

- 二进制分帧
  - HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率.
- 多路复用： 在共享TCP链接的基础上同时发送请求和响应
  - 在共享TCP链接的基础上同时发送请求和响应，基于二进制分帧，在同一域名下所有访问都是从同一个**tcp连接**中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来。
- 头部压缩
  - 由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源.
- 服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求

### 常见http状态码

* 请求正常

**200** : 从状态码发出的请求被服务器正常处理。

**204** : 服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分【即没有内

容】。

**206** : 部分的内容（如：客户端进行了范围请求，但是服务器成功执行了这部分的干请求）。

**301** : 跳转，代表永久性重定向（请求的资源已被分配了新的URI，以后已使用资源，现在设置了

URI）。

* 重定向相关

**302** : 临时性重定向（请求的资源已经分配了新的URI，希望用户本次能够使用新的URI来进行访

问）。

**303** : 由于请求对应的资源存在的另一个URI（因使用get方法，定向获取请求的资源）。

**304** : 客户端发送附带条件的请求时，服务器端允许请求访问资源.但因发生请求**未满足条件的情**

**况**后，直接返回了 304。

**307** : 临时重定向【该状态码与302有着相同的含义】。

* 用户的错

**400** : 请求报文中存在语法错误（当错误方式时，需修改请求的内容后，再次发送请求）。

**401** : 发送的请求需要有通过HTTP认证的认证信息。

**403** : 对请求资源的访问被服务器拒绝了。

**404** : 服务器上无法找到请求的资源。

* 服务器的错

**500** : 服务器端在执行请求时发生了错误。

**503** : 服务器暂时处于超负载或者是正在进行停机维护，现在无法处理请求

### Get和Post区别

1. GET参数通过URL传递，POST放在Request body中。
2. GET请求在URL中传送的参数是有长度限制的，而POST没有。

3. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

4. GET请求参数会被完整保留在浏览器历史记录里,加入到浏览器缓存中，而POST中的参数不会被保留。

5. GET请求只能进行url编码，而POST支持多种编码方式。

6. GET在浏览器回退时是无害的，而POST会再次提交请求。幂等性,多次进行访问是一致的信息,Get具有.但是post不具备,以为post上传功能导致信息可能发生变化.

   1. 在计算机科学和网络通信中，幂等性（Idempotence）是**指对同一个操作进行一次或多次的执行，结果都是相同的**。无论对某个操作执行一次还是多次，最终的状态都是一致的。这意味着重复执行不会对系统产生额外的影响或副作用。

      在HTTP协议中，幂等性通常应用于请求方法，如GET、POST、PUT、DELETE等。一个幂等的HTTP方法是指，**对同一资源的多次请求的结果都应该是相同的，不会产生重复的副作用。**


### session cookie

##### 1. 主要区别

cookie数据存放在客户的浏览器上，session数据放在服务器上。

##### 2. 由来

首先，一个网站的首页是由很多元素构成的，http本身是一种无状态的协议,（无状态：并不记录之前每次的行为和上下文数据，只在乎当前次请求是否成功）每次请求并不知道是谁发起的请求。但是实际生活中，进入网站时发起请求各种获取资源时跳转网页显示网站是认识我的，在我进行开始一次的登陆之后,这是矛盾的。

这并不是http协议本身要解决的问题，http可以提供一些技术支持来保证网站具有“会话保持”得功能，而会话管理就是由cookie和session实现的。

##### 3. Cookie

浏览器：cookie其实是一个文件，在浏览器中，保存的是我们用户的私密信息。

http协议：一旦该网站对应有cookie，在发起任何请求的时候，都会自动携带cookie信息。

后续的请求中，每一个请求都会在请求报头属性中，会自动携带对应的cookie,把个人信息等都携带，每访问一个网页都被浏览器自动交给服务器进行认证，所以在登录之后的请求中自动认识你。

Set-Cookie:在响应报文中添加这个字段，服务器向浏览器设置一个cookie，访问之后，服务器给浏览器一个返回信息写到浏览器的cookie中，相当于认证工卡，告诉他下次来得时候把认证信息也带来，下次访问就更方便了。如果你不想再让他认识你了，将cookie 文件进行移除就行了，就不认识你了.

1. cookie有两种存在形式（存在形式跟浏览器是很大关系的）

   文件版：就在浏览器的安装目录下，关闭了也认识你。

   内存版：cookie信息，浏览器这个进程一关闭再启动就会忘记你。

2. 也有可能保存浏览痕迹等其他私密信息，访问恶意网址之后，服务器会给cookie 注入木马获取到你的cookie信息，然后再在他的电脑上访问相同的网址，就可以以你的身份访问认证资源。如果当中保存着用户名和密码，就非常危险了。所以单纯的使用cookie是具有一定危险的。

##### 4. session

将用户的私密信息保存在服务器端，Session可以在多个服务器之间共享 。

保存给浏览器的cookie文件中的是当前用户的session_id(会话id)，真正的信息放在了server对应的id的磁盘文件当中，所以id是一个具有唯一性的值（时间戳形成唯一文件命名）。

后续的所有的请求都会由浏览器自动携带cookie文件当中的内容(会话id)在服务器中寻找，然后服务器进行身份检查并认证，也是一种会话保持的功能。

认证时只需要在服务器中寻找是否存在对应session_id的文件，而不再需要用户名和密码的认证。

* 但是我们还有cookie文件被盗取的风险！腾讯也保护不了你的QQ号信息。

处理方式就是,服务器可以随时让这个sessionID失效，让你重新进行认证，给你创建新的session文件和ID。手机短信验证就很有效。

* 为什么网站要让用户进行认证？就是因为每次的http请求是无状态的，需要记录访问网站时的上下文数据cookie和session本质是提高用户访问网站或者平台的体验。

### 长短连接

##### 1. 

长连接：长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。

短连接：短连接（short connnection）是相对于长连接而言的概念，指的是在数据传送过程中，只在需要发送数据时，才去建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。

##### 2. 

长连接：连接->传输数据->保持连接 -> 传输数据-> ....->直到一方关闭连接，客户端关闭连接。

长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。

短连接：连接->传输数据->关闭连接。

比如HTTP是无状态的的短链接，浏览器和[服务器](https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065)每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。因为连接后接收了数据就断开了，所以每次数据接受处理不会有联系。这也是HTTP协议无状态的原因之一。

##### 3. 

长连接：长连接多用于**操作频繁**，**点对点的通讯**，而且**连接数不能太多情况**。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。

- 例如：[数据库](https://cloud.tencent.com/solution/database?from_column=20065&from=20065)的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费

短连接：而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。

* 所以**并发量大**，但每个用户**无需频繁操作**情况下需用短连好。

##### 4. 优点

###### TCP短连接

我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作.**短连接一般只会在client/server间传递一次读写操作.**

短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。

###### TCP长连接

client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候.这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个客户端连累后端服务。

##### 总结

长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。

### http加密

* 对称加密: 用x加密,用x解密

* 非对称加密: 用公钥public加密,用私钥private解密

* 数据摘要: 对弈段文本内容采用hash散列的方式,生成一段固定长度的字符串序列,就叫做数据指纹.

* 数据签名: 对数据摘要再经过加密算法(一般是非对称加密),得到的加密结果.

* 如何判断数据是否被人修改?

1. 发送端将数据签名和文本内容一起发送,接收端对文本和签名进行分离,
2. 再用相同的hash方式对文本内容生成一段字符串,
3. 判断和数据摘要是否相同得出是否内容被人更改.

只用对称加密或者非对称加密只能保证单向的安全

* 所以,为了保证安全,在秘钥协商阶段采用非对称加密,在数据通信阶段采用对称加密.

首先服务端发送证书(公钥)到达客户端,客户端生成自己的私钥,并采用客户端公钥进行加密,传回给服务端,服务端用自己的私钥解密得到客户端的私钥,采用客户端的私钥对自己的私钥进行加密,将要传输的信息和私钥通过某种算法混合在一起（加密）传到客户端.客户端用之前的生成的随机数（私钥）解密服务器端传来的信息.



>  首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就
>
> 会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构
>
> 颁发的公钥。
>
> 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有
>
> 效期等。浏览器会先验证证书签名的合法性。签名通过后，浏览器验证证书记录的网址是否和当前
>
> 网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。
>
> 这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。

##### 中间人获取

安全不是让别人拿不到，而是别人拿到了也没办法处理。（解密的成本远大于解密之后的收益）

如果有个中间人，采用抓包系统半路截胡获取到了公开的服务器端提供的公钥S，用自身的公钥M交给了client，那么client就像前面一样，根据M形成自己的私钥X，并且用M将X进行加密，形成M+（X）想返回给服务器，但是服务器只认识S，所以M+又被中间人获取，中间人通过私钥M’对M+进行解密，得到了客户端的私钥X，同时将服务器的公钥S加密X返回给服务器，这样就狸猫换太子般的得到了服务器和客户端之间进行对称加密的私钥X，就可以在日后的信息交互中获取信息。

其中client并不知道秘钥协商报文是不是合法服务器发来的。

##### CA机构的作用

公司给CA机构发送自己的文本个人信息(域名+公钥S等)，CA机构创建证书，CA将文本信息经过哈希散列的方式形成数据摘要(指纹)，也就是一段唯一的字符序列，再用自己独一无二的私钥对摘要进行加密形成数据签名，最后将数据签名和公司提交的文本内容形成的证书一并返回给公司。

那么之后，client端发送请求，server端直接发送证书（内置自己的公钥S），即便中间商获取，用CA机构公开的公钥进行解密证书中的数字签名，修改对应的内容生成新的数据摘要和签名，但是由于没有CA机构加密的私钥，无法形成和CA机构一样加密形式的数据签名，即便修改了内容，客户端也能区分出来不一样，

客户端用CA机构的公钥将数据签名解密得到一份数据摘要，将整数中的文本进行哈希散列形成一份数据摘要，如果两份不一样就说明内容遭到了修改。