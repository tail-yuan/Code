#### rwnd滑动窗口

在TCP（传输控制协议）中，rwnd 是接收窗口（Receive Window）的缩写，它表示接收端可以接收的未确认数据的最大数量，以字节为单位。rwnd 是用来管理流量控制的一个重要参数，用于确保发送端不会发送太多数据，超出接收端的处理能力。

rwnd 的工作方式如下：

1. 发送端（TCP 客户端）将其拥有的数据分成一系列的 TCP 段并发送给接收端（TCP 服务器）。

2. 接收端会根据自身的处理能力和可用内存空间大小来确定 rwnd 的值。rwnd 表示接收端当前可以接收的字节数。

3. 发送端会根据接收端提供的 rwnd 值来控制发送数据的速率。它不会发送超过 rwnd 大小的数据，以确保接收端能够及时处理和缓存数据。

4. 接收端在处理数据后会释放相应的内存空间，从而增加 rwnd 的值，使发送端能够发送更多的数据。

通过 rwnd，TCP 实现了流量控制，防止了发送端发送过多的数据，从而避免了数据的丢失和网络拥塞。这有助于确保数据可靠地传输并维护网络性能。

请注意，rwnd 是动态调整的，它会根据接收端的状态和处理速度来变化。发送端会根据 rwnd 值来调整发送速率，以适应接收端的处理能力，从而实现了有效的数据传输控制。

### 保活机制 keep-alive

> TCP的keepalive机制和HTTP的keep-alive机制是说的完全不同的两个东西，
>
> tcp的keepalive是在ESTABLISH状态的时候，双方如何检测连接的可用行。
>
> 而http的keep-alive说的是如何避免进行重复的TCP三次握手和四次挥手的环节。

#### HTTP keep-alive

在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要,造成长短连接.

#### TCP keep-alive

链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。

TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的探测报文,如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：

1. 客户主机依然正常运行，并且服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保证定时器复位。
2. 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
3. 客户主机崩溃并已经重新启动。服务器将收到一个对其保证探测的响应，这个响应是一个复位，使得服务器终止这个连接。
4. 客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。

### 服务器判断连接是否断开

1. 检测连接是否丢失的方法大致有两种：**keepalive**和**heart-beat**

2. （tcp内部机制）采用keepalive，它会先要求此连接一定时间没有活动（一般是几个小时），然后

发出数据段，经过多次尝试后（每次尝试之间也有时间间隔），如果仍没有响应，则判断连接中

断。可想而知，整个**周期需要很长**的时间。

3. （应用层实现）一个简单的heart-beat实现一般测试连接是否中断采用的时间间隔都比较短，可以

**很快的决定连接是否中断**。并且，由于是在应用层实现，因为可以自行决定当判断连接中断后应该

采取的行为，而keepalive在判断连接失败后只会将连接丢弃。

### tcp如何加速大文件传输

1. 建连优化：TCP 在建立连接时，如果丢包，会进入重试，重试时间是 1s、2s、4s、8s 的指数递增间隔，缩短定时器可以让 TCP 在丢包环境建立连接时间更快，非常适用于高并发短连接的业务场景。

2. 平滑发包：在 RTT (一个来回的时间)内均匀发包，规避微分时间内的流量突发，尽量避免瞬间拥塞
3. 丢包预判：有些网络的丢包是有规律性的，例如每隔一段时间出现一次丢包，例如每次丢包都连续丢几个等，如果程序能自动发现这个规律（有些不明显），就可以针对性提前多发数据，减少重传时间、提高有效发包率。

4. RTO 探测：若始终收不到 ACK 报文，则需要触发 RTO 定时器。RTO 定时器一般都时间非常长，会浪费很多等待时间，而且一旦 RTO，CWND 就会骤降（标准 TCP），因此利用 Probe 提前与RTO 去试探，可以规避由于 ACK 报文丢失而导致的速度下降问题。

5. 带宽评估：通过单位时间内收到的 ACK 或 SACK 信息可以得知客户端有效接收速率，通过这个速率可以更合理的控制发包速度。

6. 带宽争抢：有些场景（例如合租）是大家互相挤占带宽的，假如你和室友各 1Mbps 的速度看电影，会把 2Mbps 出口占满，而如果一共有 3 个人看，则每人只能分到 1/3。若此时你的流量流量达到 2Mbps，而他俩还都是 1Mbps，则你至少仍可以分到 2/(2+1+1) * 2Mbps = 1Mbps 的 50%的带宽，甚至更多，代价就是服务器侧的出口流量加大，增加成本。（TCP 优化的本质就是用带宽换用户体验感）

### 延迟应答

延迟应答指的是：TCP在接收到对端的报文后，并不会立即发送ack，而是等待一段时间发送ack，以便将ack和要发送的数据一块发送。当然ack不能无限延长，否则对端会认为包超时而造成报文重传。linux采用动态调节算法来确定延时的时间。

### 确认应答(累计应答)

累计应答指的是：为了保证**顺序性**，每一个包都有一个**ID**（序号），在建立连接的时候，会商定起始的ID是多少，然后按照ID一个个发送。而为了保证不丢包，对应发送的包都要进行应答，但不是一个个应答，而是会**应答某个之前的**ID，该模式称为**累计应答**.

###  UDP如何可靠

1. UDP仅提供了最基本的数据传输功能，至于传输时连接的建立和断开、传输可靠性的保证这些UDP统统不关心，而是把这些问题抛给了UDP上层的应用层程序去处理，自己仅提供传输层协议的最基本功能。
2. 最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。

- 添加序号和确认应答机制，确保数据发送到对端
- 添加发送和接收缓冲区，支持滑动窗口实现流量控制,方便重传机制.
- 添加超时重传机制。

### TCP UDP区别

TCP和UDP协议都是**传输层**协议。二者的区别主要有：

1. ###### 基于连接vs无连接

TCP是面向连接的协议。

UDP是无连接的协议。UDP更加适合消息的多播发布，从单个点向多个点传输消息。

2. ###### 可靠性

TCP提供交付保证，传输过程中丢失，将会重发。

UDP是不可靠的，不提供任何交付保证。（网游和视频的丢包情况）

3. ###### 有序性

TCP保证了消息的有序性，即使到达客户端顺序不同，TCP也会排序。

UDP不提供有序性保证。

4. ###### 数据边界

TCP不保存数据边界。虽然TCP也将在收集所有字节之后生成一个完整的消息，但是这些信息在传给传输给接受端之前将储存在TCP缓冲区，以确保更好的使用网络带宽。

UDP保证。在UDP中，数据包单独发送的，只有当他们到达时，才会再次集成。包有明确的界限来哪些包已经收到，这意味着在消息发送后，在接收器接口将会有一个读操作，来生成一个完整的消息。

5. ###### 速度

TCP速度慢

UDP速度快。应用在在线视频媒体，电视广播和多人在线游戏。

6. ###### 发送消耗

TCP是重量级。

UDP是轻量级。因为UDP传输的信息中不承担任何间接创造连接，保证交货或秩序的的信息。这也反映在用于报头大小。

7. ###### 报头大小

TCP头大。一个TCP数据包报头的大小是20字节。TCP报头中包含序列号，ACK号，数据偏移量，保留，控制位，窗口，紧急指针，可选项，填充项，校验位，源端口和目的端口。

UDP头小。UDP数据报报头是8个字节。而UDP报头只包含长度，源端口号，目的端口，和校验和。

8. ###### 拥塞或流控制

TCP有流量控制。在任何用户数据可以被发送之前，TCP需要三数据包来设置一个套接字连接。TCP处理的可靠

性和拥塞控制。

UDP不能进行流量控制。

9. ###### 应用

由于TCP提供可靠交付和有序性的保证，它是最适合需要高可靠并且对传输时间要求不高的应用。

UDP是更适合的应用程序需要快速，高效的传输的应用，如游戏。UDP是无状态的性质，在服务器端需要对大量客户端产生的少量请求进行应答的应用中是非常有用的。

在实践中，TCP被用于金融领域，如FIX协议是一种基于TCP的协议，而UDP是大量使用在游戏和娱乐场所。

###### 10.上层使用的协议

基于TCP协议的：Telnet，FTP以及SMTP协议。

* MTP是一种提供可靠且有效的[电子邮件传输](https://baike.baidu.com/item/电子邮件传输/22035911?fromModule=lemma_inlink)的协议。SMTP是建立在FTP[文件传输服务](https://baike.baidu.com/item/文件传输服务/5389842?fromModule=lemma_inlink)上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。

基于UDP协议的：DHCP、DNS、SNMP、TFTP、BOOTP。

* DHCP: **动态主机设置协议**（英语：**D**ynamic **H**ost **C**onfiguration **P**rotocol，缩写：**DHCP**），又称**动态主机组态协定**，是一个用于[IP](https://zh.wikipedia.org/wiki/网际协议)网络的[网络协议](https://zh.wikipedia.org/wiki/网络协议)，位于[OSI模型](https://zh.wikipedia.org/wiki/OSI模型)的[应用层](https://zh.wikipedia.org/wiki/应用层)，使用[UDP](https://zh.wikipedia.org/wiki/用户数据报协议)协议工作，主要有两个用途：
  - 用于内部网或网络服务供应商自动分配[IP地址](https://zh.wikipedia.org/wiki/IP地址)给用户
  - 用于内部网管理员对所有电脑作中央管理

* DNS: 域名解析协议

* SNMP: 是专门设计用于在 [IP](https://baike.baidu.com/item/IP/224599?fromModule=lemma_inlink) [网络管理](https://baike.baidu.com/item/网络管理/5903609?fromModule=lemma_inlink)[网络节点](https://baike.baidu.com/item/网络节点/9338583?fromModule=lemma_inlink)（服务器、工作站、路由器、交换机及Hubs等）的一种标准协议，它是一种[应用层协议](https://baike.baidu.com/item/应用层协议/3668945?fromModule=lemma_inlink)。 SNMP 使[网络管理员](https://baike.baidu.com/item/网络管理员/595848?fromModule=lemma_inlink)能够管理网络效能，发现并解决网络问题以及规划网络增长。通过 SNMP接收随机消息（及事件报告）[网络管理系统](https://baike.baidu.com/item/网络管理系统/6485945?fromModule=lemma_inlink)获知网络出现问题。
* TFTP（Trivial File Transfer Protocol,简单[文件传输协议](https://baike.baidu.com/item/文件传输协议?fromModule=lemma_inlink)）是TCP/IP协议族中的一个用来在客户机与[服务器](https://baike.baidu.com/item/服务器?fromModule=lemma_inlink)之间进行简单文件传输的协议，提供不复杂、开销不大的[文件传输服务](https://baike.baidu.com/item/文件传输服务/5389842?fromModule=lemma_inlink)。[端口号](https://baike.baidu.com/item/端口号/10883658?fromModule=lemma_inlink)为69。

* BOOTP（Bootstrap Protocol，引导程序协议）是一种引导协议，基于IP/UDP协议，也称自举协议，是**DHCP协议的前身**。BOOTP用于无盘工作站的局域网中，可以让无盘工作站从一个中心[服务器](https://baike.baidu.com/item/服务器/100571?fromModule=lemma_inlink)上获得IP地址。通过BOOTP协议可以为[局域网](https://baike.baidu.com/item/局域网/98626?fromModule=lemma_inlink)中的[无盘工作站](https://baike.baidu.com/item/无盘工作站/945496?fromModule=lemma_inlink)分配[动态IP地址](https://baike.baidu.com/item/动态IP地址?fromModule=lemma_inlink)，这样就不需要管理员去为每个用户去设置静态IP地址。

### MSL

MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

* ##### 为什么要等待2MSL时间才关闭连接?

为了保证客户端发送的最后一个ACK报文段能够到达服务器。

因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

###### 两个理由：

* 保证客户端发送的最后一个ACK报文段能够到达服务端。

这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。

* 让之前发送所有数据全部消失

客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段.

###  三次握手

![image-20230910140708351](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230910140708351.png)



#### 握手过程

> 1）第一次握手：建立连接时，客户端向服务器发送SYN包（seq=x），请求建立连接，等待确认
>
> 2）第二次握手：服务端收到客户端的SYN包，回一个ACK包（
>
> ACK=x+1）确认收到，同时发送一个SYN
>
> 包（seq=y）给客户端
>
> 3）第三次握手：客户端收到SYN+ACK包，再回一个ACK包（
>
> ACK=y+1）告诉服务端已经收到
>
> 4）三次握手完成，成功建立连接，开始传输数据

#### 握手发生问题

> 1. 如果第一次握手消息丢失，那么请求方不会得到ack消息，超时后进行重传
>
> 2. 如果第二次握手消息丢失，那么请求方不会得到ack消息，超时后进行重传
>
> 3. 如果第三次握手消息丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。而Server重发SYN+ACK包的次数，可以设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.
>
>    如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。client 一般是通过 connect() 函数来连接服务器的，而connect()是在 TCP的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK包，它的TCP连接状态就为 established(已连接），表示该连接已经建立。那么如果 第三次握手中的ACK包丢失的情况下，Client 向server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。

### 四次挥手

![image-20230910140852519](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230910140852519.png)

> 1）客户端发送FIN包（FIN=1)给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时客户端不发送数据，但还能接收数据
>
> 2）服务端收到FIN包，回一个ACK包给客户端告诉它已经收到包了，此时还没有断开socket连接，而是等待剩下的数据传输完毕
>
> 3）服务端等待数据传输完毕后，向客户端发送FIN包，表明可以断开连接
>
> 4）客户端收到后，回一个ACK包表明确认收到，等待一段时间，确保服务端不再有数据发过来，然后彻底断开连接

### 连接状态描述

**CLOSED** 

阻塞或关闭状态，表示主机当前没有正在传输或者建立的链接

**LISTEN** 

监听状态，表示服务器做好准备，等待建立传输链接

**SYN RECV** 

收到第一次的传输请求，还未进行确认

**SYN SENT** 

发送完第一个SYN报文，等待收到确认

**ESTABLISHED** 

链接正常建立之后进入数据传输阶段

**FIN WAIT1** 

主动发送第一个FIN报文之后进入该状态

**FIN WAIT2** 

已经收到第一个FIN的确认信号，等待对方发送关闭请求

**TIMED WAIT** 

完成双向链接关闭，等待分组消失

**CLOSING** 

双方同时关闭请求，等待对方确认时

**CLOSE WAIT** 

收到对方的关闭请求并进行确认进入该状态

**LAST ACK** 

等待最后一次确认关闭的报文

### TCP连接慢启动

 **慢启动**（Slow Start），是传输控制协议（TCP）使用的一种阻塞控制机制。

慢启动也叫做指数增长期。慢启动是指每次TCP接收窗口收到确认时都会增长。增加的大小就是已确认段的数目。这种情况一直保持到要么没有收到一些段，要么窗口大小到达预先定义的阈值。如果发生丢失事件，TCP就认为这是网络阻塞，就会采取措施减轻网络拥挤。一旦发生丢失事件或者到达阈值，TCP就会进入线性增长阶段。这时，每经过一个RTT窗口增长一个段。

### TCP保证有序

主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机

对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送

主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否

有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数

据流并传递到高层进行处理。

具体步骤如下：

（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；

（2）并为每个已发送的数据包启动一个超时定时器；

（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;

（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。

（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去.

### TCP拥塞算法

1. TCP Tahoe/Reno

   最初的实现，包括慢启动、拥塞避免两个部分。基于重传超时（retransmission timeout/RTO）和重复确认为条件判断是否发生了丢包。

   两者的区别在于：Tahoe算法下如果收到三次重复确认，就进入快重传立即重发丢失的数据包，同时将慢启动阈值设置为当前拥塞窗口的一半，将拥塞窗口设置为1MSS，进入慢启动状态；

   而Reno算法如果收到三次重复确认，就进入快重传，但不进入慢启动状态，而是直接将拥塞窗口减半，进入拥塞控制阶段，这称为“快恢复”。而Tahoe和Reno算法在出现RTO时的措施一致，都是将拥塞窗口降为1个MSS，然后进入慢启动阶段。

2. TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）

BBR是由Google设计，于2016年发布的拥塞算法。以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而BBR则基于模型主动探测。

该算法使用网络最近出站数据分组当时的最大带宽和往返时间来建立网络的显式模型。

数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，例如CUBIC。

#### TCP如何感知网络拥塞

TCP的拥塞控制是通过观察网络的传输状况和监测反馈信息来判断当前网络情况的。TCP拥塞控制使用了一系列算法和机制来适应网络的变化，以避免网络拥塞和保持流量的稳定性。

以下是TCP拥塞控制判断当前网络情况的一些方法：

1. **丢包检测**：
   当网络出现拥塞时，路由器可能会**丢弃部分数据包**。TCP的发送方通过监测是否收到确认（ACK）来判断数据是否被成功传输。如果未收到确认或收到3次重传请求，TCP将认为网络出现拥塞，并触发拥塞控制机制。

2. **延迟检测**：
   TCP通过测量数据包的往返时间（RTT）来检测网络的延迟情况。较高的延迟可能是网络拥塞的标志之一。

3. **接收窗口**：
   TCP的接收方会通过设置接收窗口来告知发送方可以接收的数据量。**如果接收窗口较小，说明接收方的处理速度较慢**，可能是网络拥塞的表现之一。

4. **拥塞窗口**：
   TCP使用拥塞窗口来限制发送方发送数据的速率。当网络出现拥塞时，发送方会降低拥塞窗口的大小，减少发送的数据量。

5. **慢启动和拥塞避免**：
   TCP在连接建立时会进行**慢启动**，以探测网络的带宽和拥塞程度。接着进入拥塞避免阶段，增加拥塞窗口的大小，逐渐提高发送速率。

6. **重传超时**：
   TCP设置了**重传超时时间**，在超过这个时间后仍未收到确认，将触发数据的重传。如果频繁触发重传，可能是网络拥塞的迹象。

通过以上方法，TCP可以实时地感知网络的状况，并根据情况进行拥塞控制，以保持网络流量的稳定性和合理利用网络带宽。这些拥塞控制算法和机制使得TCP在不同网络环境下都能表现出很好的性能和可靠性。

### 超时重传

TCP可靠性中最重要的一个机制是处理数据超时和重传。TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。

### TCP保证可靠性的机制

TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。

##### 校验和

通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部.

##### 基于序号的确认应答机制

这个机制类似于问答的形式。比如在课堂上老师会问你“明白了吗？”，假如你没有隔一段时间没有回应或者你说不明白，那么老师就会重新讲一遍。其实计算机的确认应答机制也是一样的，发送端发送信息给接收端，接收端会回应一个包，这个包就是应答包。

![image-20230910143522585](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230910143522585.png)

上述过程中，只要发送端有一个包传输，接收端没有回应确认包（ACK包），都会重发。或者接收端的应答包，发送端没有收到也会重发数据。这就可以保证数据的完整性。

##### 超时重传

超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。

- 那么我们该如何确认这个时间值呢？

我们知道，一来一回的时间总是差不多的，都会有一个类似于平均值的概念。比如发送一个包到接收端收到这个包一共是0.5s，然后接收端回发一个确认包给发送端也要0.5s，这样的两个时间就是RTT（往返时间）。然后可能由于网络原因的问题，时间会有偏差，称为抖动（方差）。从上面的介绍来看，超时重传的时间大概是比往返时间+抖动值还要稍大的时间。

但是在重发的过程中，假如一个包经过多次的重发也没有收到对端的确认包，那么就会认为接收端异常，强制关闭连接。并且通知应用通信异常强行终止。

![image-20230910143636772](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230910143636772.png)

##### 流量控制

滑动窗口

##### 拥塞控制

拥塞窗口

### 滑动窗口

1. 滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。TCP的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。

2. TCP在发送数据时会设置一个计时器，若到计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为重传超时（RTO） 。
   1. 另一种方式的重传称为快速重传，通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文时，快速重传会推断出现丢包，需要重传

滑动窗口的大小对网络性能有很大的影响。如果滑动窗口过小，则需要在网络上频繁的传输确认信息，占用了大量的[网络带宽](https://zhidao.baidu.com/search?word=网络带宽&fr=iknow_pc_qb_highlight)；如果滑动窗口过大，对于利用率较高，容易产生丢包现象的网络，则需要多次发送重复的数据，也同样耗费了网络带宽.

### SYN洪水

SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS(分布式拒绝服务攻击)的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，使被攻击方资源耗尽（CPU满负荷或内存不足)的攻击方式