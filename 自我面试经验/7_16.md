#### 求数据之间的交集

1. 数据分片：将每个集合划分为多个分片，并将它们存储在不同的机器上。确保在分片过程中，相同的元素被划分到相同的分片中。
2. 并行计算：在每个机器上并行地计算每个分片的交集。可以使用MapReduce模式，其中Map阶段处理每个分片并输出(key, value)对，其中key是元素，value可以是一个标识符表明该元素在哪个集合中。然后，在Reduce阶段，合并具有相同键的输出对，找到存在于两个集合中的元素。
3. 合并结果：收集并合并每个机器的计算结果，得到最终的交集。

#### 静态变量使用场景

1. 共享数据：**静态变量在多个函数之间共享数据时非常有用**。通过在一个函数中定义静态变量，可以在函数调用之间保留该变量的值，从而实现数据的共享。这对于需要在多个函数中跟踪某个状态或共享一些计数器的情况非常有用。
2. 计数器：静态变量在计数或跟踪某个事件发生的次数时很有用。可以在函数中定义一个静态变量，每次调用函数时将计数器递增，从而**记录该函数被调用的次数**。记录函数别递归调用的次数.
3. 类当中函数或变量定义为静态数据,属于整个类不属于某一个初始化的对象.

#### 多线程访问静态变量数据不一致问题

当多线程同时读写**同一个静态变量**时，可能会引发竞态条件（race condition）和数据不一致的问题。为了解决这个问题，可以采用以下几种方法：

1. **互斥锁（Mutex）**：使用互斥锁来保护对静态变量的读写操作。在访问静态变量之前，线程必须获取互斥锁，**确保同一时间只有一个线程可以访问该变量。其他线程将被阻塞，直到互斥锁被释放**。这样可以保证对静态变量的访问是串行化的，避免竞态条件。

2. 原子操作（Atomic Operations）：使用原子操作来对静态变量进行读写。**原子操作是不可中断的操作，可以确保多线程环境下的数据一致性**。C++标准库提供了一些原子操作的类型和函数，如std::atomic，可以用于对静态变量进行原子操作。

3. 读写锁（Read-Write Lock）：使用读写锁来控制对静态变量的读写访问。**读写锁允许多个线程同时读取静态变量，但只允许一个线程进行写操作。这样可以提高读操作的并发性能，同时保证写操作的独占性。**

4. 使用线程安全的数据结构：考虑使用线程安全的数据结构来替代直接操作静态变量。例如，可以使用**std::mutex或std::atomic提供的容器或数据结构**，如std::mutex，std::atomic_flag等，来存储需要共享的数据。

需要根据具体情况选择合适的解决方案。在实现时，要确保对静态变量的访问是正确同步的，**以避免数据竞争和不一致性的问题**。此外，还应该注意锁的粒度和性能开销，以及避免死锁等并发编程中常见的问题。

#### 原子量和无锁编程

原子量（Atomic）是**一种并发编程中用于实现线程安全操作的特殊类型**。它是一个可被多个线程同时访问的变量，而不需要显式的锁机制。原子量确保了对该变量的操作是原子的、不可中断的，并且在多线程环境下保持一致性。

在C++中，`std::atomic`是一个模板类，**用于创建原子类型的变量**。`std::atomic`提供了一组原子操作，包括读、写、比较和交换等。这些原子操作能够确保对原子量的访问和修改是线程安全的，并且在多线程环境中不会导致竞态条件。

使用原子量**可以避免使用互斥锁或其他同步机制**，从而提高并发性能。它适用于一些简单的操作，如递增、递减、比较、交换等，并且在高度竞争的情况下表现良好。

以下是一个示例，展示了如何使用`std::atomic`来创建原子量：

```cpp
#include <iostream>
#include <atomic>

std::atomic<int> counter(0);  // 原子量

int main() {
    counter.store(42);  // 原子写操作

    int value = counter.load();  // 原子读操作
    std::cout << "Counter value: " << value << std::endl;

    counter.fetch_add(10);  // 原子递增操作

    value = counter.fetch_sub(5);  // 原子递减操作
    std::cout << "Counter value: " << value << std::endl;

    return 0;
}
```

在这个示例中，我们创建了一个原子量`counter`，初始值为0。通过使用`std::atomic`，我们可以对该原子量进行原子读写、递增、递减等操作。

在`main`函数中，我们使用`store`函数进行原子写操作，将值42存储到原子量中。然后，使用`load`函数进行原子读操作，获取原子量的值并输出。

接下来，我们使用`fetch_add`函数进行原子递增操作，将原子量的值增加10。然后，使用`fetch_sub`函数进行原子递减操作，将原子量的值减去5。在递增和递减操作中，这些函数返回了之前的值。

通过使用`std::atomic`，我们可以确保对原子量的访问和修改是线程安全的，而无需显式的锁机制。

```C++
//展示了无锁编程的概念。
//该示例使用原子操作来实现一个简单的计数器，多个线程可以同时对计数器进行递增操作。

//所谓的无锁编程就是想问你有哪些方式可以实现并发场景下的原子操作,不让用锁,
//就用Linux系统提供的原子类型atomic_t C++标准库提供了一些原子操作的类型和函数，如std::atomic，可以用于对静态变量进行原子操作。
//使用线程安全的数据结构：考虑使用线程安全的数据结构来替代直接操作静态变量。
//例如，可以使用std::mutex或std::atomic提供的容器或数据结构
//自旋锁,信号量,
#include<iostream>
#include<pthread.h>
#include<atomic>
using namespace std;
#define NUM 5
std::atomic<int>counter(0);

void* incrementCounter(void* args)
{
    int tid= *(int*)args;
    for(int i=0;i<10000;i++)
    {
        counter.fetch_add(1,std::memory_order_relaxed);
    }
    return nullptr;
}
int main()
{
    pthread_t tid[NUM];
    for(int i=0;i<NUM;i++)
        pthread_create(&tid[i],nullptr,incrementCounter,(void*)&tid[i]);
    for(int i=0;i<NUM;i++)
        pthread_join(tid[i],nullptr);
    cout<<"Counter Value:"<<counter<<endl;
    return 0;
}
```

#### 简单聊聊C++多线程

"C++多线程是一种**并发编程的技术**，允许程序在同一时间执行多个线程。多线程**可以同时执行不同的任务**，使得程序可以更高效地利用计算资源。通过使用线程，我们可以并行处理独立的任务，提高程序的性能和响应性。C++提供了多线程编程的支持，例如使用`std::thread`类创建线程、使用**互斥锁或原子操作确保线程安全访问共享数据**。多线程编程在处理大规模计算、异步处理、并行算法等领域非常有用，但也需要注意线程同步和竞态条件等并发编程中的常见问题。"

这段简洁的说明概括了C++多线程的核心概念，包括并发执行、提高性能和响应性、使用`std::thread`创建线程、线程安全性、并发编程中的常见问题等。

#### C++异步

C++提供了异步编程的支持，可以通过异步操作来实现**并发和非阻塞的程序执行**。以下是对C++异步编程的简洁说明：

"C++异步编程是一种编写并发、非阻塞程序的技术。**异步操作允许程序执行任务时不需要等待结果，而是可以继续执行其他操作**。在C++中，可以使用异步任务来执行耗时的操作，如**网络请求、磁盘读写、计算密集型任务**等。C++提供了多种方式来实现异步编程，例如使用`std::async`函数创建异步任务、使用`std::future`来获取异步操作的结果、使用回调函数或lambda表达式来处理异步任务的完成事件。异步编程可以提高程序的并发性能和响应性，特别适用于需要处理大量并发任务或与外部资源进行交互的场景。但是，在异步编程中需要考虑线程安全性、同步和数据共享等并发编程中的挑战。"

这段简洁的说明概括了C++异步编程的关键点，包括非阻塞执行、耗时操作、`std::async`、`std::future`、回调函数和lambda表达式的使用、并发性能和响应性、线程安全性和并发编程的挑战等。

##### 异步编程

我们定义了一个`performTask`函数，模拟一个耗时的操作。在主函数中，我们使用`std::async`函数启动一个异步任务，传递`performTask`函数和参数10作为参数。`std::launch::async`参数指定了启动方式，表示该异步任务应在新线程中执行。

接着，我们在主函数中继续执行其他操作，而不需要等待异步任务完成。这是异步编程的关键点，我们可以继续执行其他任务，而异步任务在后台执行。

最后，我们通过调用`futureResult.get()`来获取异步任务的结果。这会阻塞主线程，直到异步任务完成并返回结果。然后，我们将结果输出到控制台。

通过使用`std::async`和`std::future`，我们实现了一个简单的异步逻辑，使程序能够并发执行其他任务，并在需要时获取异步任务的结果。

```C++
//实现异步编程简单逻辑
#include<iostream>
#include<future>
using namespace std;

int performTask(int n)//新起一个线程作为异步函数,模拟耗时操作
{
    cout<<"Performing task..."<<endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));
    return n*2;
}
int main()
{
    std::future<int> future_result=async(std::launch::async,performTask,10);
    
    cout<<"Performing other task..."<<endl;

    int ret=future_result.get();
    cout<<"输出结果是:"<<ret<<endl;

}
[root@yuanwei test_code]# g++ async.cc -o async -lpthread
[root@yuanwei test_code]# ./async 
Performing other task...Performing task...

输出结果是:20
```

#### 线程池作用

线程池是一种**管理和复用线程的机制**，它在应用程序中创建一组预先初始化的线程，并且根据需要分配任务给这些线程来执行。线程池的作用主要体现在以下几个方面：

1. 提高性能和响应性：线程池可以**在应用程序启动时创建一组线程**，并将它们保持活动状态。这样，**在任务到达时，可以避免为每个任务创建和销毁线程的开销，从而提高性能和响应性**。线程池能够更高效地利用系统资源，避免频繁地创建和销毁线程所带来的开销。

2. 控制并发度：**线程池可以限制同时执行的任务数量，从而控制并发度**。通过设置线程池的大小，可以确保在系统负载过高时不会创建过多的线程，防止资源耗尽和性能下降。同时，线程池也可以根据需要动态调整线程数量，以适应不同的负载情况。

3. 任务调度和管理：**线程池负责接收、调度和管理任务的执行**。应用程序可以将任务提交给线程池，线程池会根据**任务队列中的任务和可用的线程来分配任务**，并执行任务的调度和管理。线程池还可以提供一些附加功能，如任务优先级、任务超时处理等。

4. 避免线程创建和销毁的问题：线程的创建和销毁是一项开销较大的操作，可能导致资源浪费和系统性能下降。通过使用线程池，可以避免频繁地创建和销毁线程，提高系统的效率和性能。线程池中的线程可以被重复使用，从而**减少了线程创建和销毁的开销**。

总的来说，线程池提供了一种优化多线程应用程序的机制，它通过管理和复用线程，提高了系统的性能、响应性和资源利用率，同时简化了任务的调度和管理。线程池在并发编程中被广泛应用，特别适用于需要处理大量短期任务的场景。

#### 数据库并发场景处理

数据库的并发问题是在多个用户或进程同时访问和修改数据库时出现的一系列潜在问题。这些问题包括数据一致性、并发控制、并发修改冲突等。为了解决数据库的并发问题，可以考虑以下几种方法：

1. 事务管理：**使用事务来维护数据库的一致性和隔离性**。事务是一组数据库操作的逻辑单元，要么全部执行成功，要么全部回滚，保证了数据的一致性。**通过合理地划分事务的边界和事务的隔离级别，可以避免并发操作导致的数据冲突和脏读等问题**。
2. 并发控制：采用合适的并发控制机制来管理并发操作。常见的并发控制技术包括**锁机制**（如共享锁和排他锁）、**并发事务控制（如多版本并发控制 (MVCC)）**、**并发控制算法（如读写锁、信号量等）**。这些机制可以确保并发操作的正确执行，避免数据冲突和不一致性。
3. 死锁避免和解决：死锁是并发操作中常见的问题，当多个进程相互等待对方持有的资源时发生。为了避免死锁，可以采用死锁预防策略（如资源有序分配、避免循环等）和死锁检测与解决策略（如死锁检测算法、资源抢占和回滚等）。
5. 并发性能优化：对于高并发的数据库系统，还可以通过一些性能优化策略来提高并发性能，如**合理的索引设计、查询优化、缓存技术等**。这些技术可以减少数据库操作的开销和响应时间，提高并发处理能力。

需要注意的是，并发问题的解决是一个复杂的领域，取决于 具体的应用场景和数据库系统的特点。因此，针对具体问题，需要综合考虑并发控制、事务管理和性能优化等因素，选择合适的解决方案。

##### MVCC

在MySQL数据库中，MVCC代表多版本并发控制（Multi-Version Concurrency Control）。**MVCC是一种并发控制机制**，用于处理数据库中的并发访问和修改操作。

在MVCC中，每个数据库事务都可以看到数据库**在其开始时间点之前已提交的数据版本**。这意味着事务在读取数据时不会受到其他事务正在修改数据的影响。当事务修改数据时，它会创建该数据的新版本，并将其写入数据库。这样，不同的事务可以并发地读取和修改不同版本的数据，避免了冲突和数据不一致性的问题。

MySQL使用MVCC来实现事务的隔离性，其中包括以下关键组件：

1. 版本号：每个数据行都包含一个版本号，用于标识该数据行的当前版本。

2. 事务ID：每个事务都有一个唯一的事务ID，用于标识事务的开始时间点。

3. Read View（读视图）：每个事务在开始时创建一个读视图，**用于确定在该事务开始之前已提交的数据版本**。读视图会记录该事务开始时的数据库版本号。

4. Undo Log（撤销日志）：在事务修改数据时，MySQL会将旧版本的数据存储在撤销日志中，以便在事务回滚或其他事务需要读取旧版本时进行恢复。

通过使用MVCC，MySQL实现了高度的并发性和事务隔离级别。它允许多个事务同时读取数据库，并且在没有互斥锁的情况下保持一致性。每个事务通过读视图确定自己可见的数据版本，从而实现了数据的一致性和隔离性。

需要注意的是，MVCC在MySQL中是默认开启的，并且适用于具有可重复读隔离级别的事务。在其他隔离级别下，MySQL可能会使用其他并发控制机制来处理并发问题。





#### epoll相较于select的优点

​	- 接口使用方便: 虽然拆分成了三个函数, 但是反而使用起来更方便高效. 不需要每次循环都设置关注的文件描述符, 也做到了输入输出参数分离开

​	- 数据拷贝轻量: 只在合适的时候调用 EPOLL_CTL_ADD 将文件描述符结构拷贝到内核中, 这个操作并不频繁(而select/poll都是每次循环都要进行拷贝)

​	- 事件回调机制: 避免使用遍历, 而是使用回调函数的方式, 将就绪的文件描述符结构加入到就绪队列中, epoll_wait 返回直接访问就绪队列就知道哪些文件描述符就绪. 这个操作时间复杂度O(1). 即使文件描述符数目很多, 效率也不会受到影响. 

​	- 没有数量限制: 文件描述符数目无上限.

[顶级理解](https://blog.csdn.net/gymaisyl/article/details/83962671)

相较于 select，epoll 具有以下几个优点：

1. 高性能：epoll 使用基于事件驱动的方式，通过回调机制只处理活跃的文件描述符，避免了**每次调用时线性扫描全部文件描述符的开销**，因此在大规模并发连接的场景下性能更高。

2. 没有文件描述符限制：select 的文件描述符集合是一个固定大小的位图，通常是 1024 个或更小。而 epoll 使**用一个事件表来保存需要监控的文件描述符**，不会有固定的限制。

3. 内核与用户空间共享事件表：**epoll 允许用户空间将事件表（事件集合）直接传递给内核**，*而不需要将文件描述符复制到内核。这样，减少了内核与用户空间之间的数据拷贝，提高了性能。*

4. 更高效的事件通知机制：epoll 使用基于事件的通知机制，当文件描述符的状态发生变化时，内核只通知用户空间该文件描述符所对应的事件，而不需要遍历所有的文件描述符。**这种事件驱动的方式避免了对无效事件的轮询，提高了系统的响应速度。**

5. 支持水平触发和边缘触发模式：epoll 可以设置为水平触发（Level Triggered）模式和边缘触发（Edge Triggered）模式。水平触发模式在文件描述符就绪状态仍然存在时会一直通知，而边缘触发模式**只在文件描述符状态发生变化时**通知一次。边缘触发模式可以减少不必要的事件通知，提高效率。

综上所述，相较于 select，epoll 在大规模并发连接和高性能的场景下具有更好的性能和可扩展性。它通过减少内核与用户空间之间的数据拷贝、高效的事件通知机制和没有文件描述符限制等优势，使得它成为了较为主流的事件驱动的 I/O 多路复用机制。

##### 触发模式

ET和LT（水平触发）是两种事件触发模式，用于描述操作系统在处理I/O事件时的行为。

- 边缘触发（ET）模式：在ET模式下，当I/O事件状态发生变化时，操作系统只会通知一次，直到应用程序处理完这个事件。如果应用程序没有读取或写入足够的数据，操作系统将不会再次通知事件就绪状态。

- 水平触发（LT）模式：在LT模式下，当I/O事件状态发生变化时，操作系统会重复通知应用程序，直到应用程序主动处理该事件为止。即使应用程序没有读取或写入足够的数据，操作系统也会重复通知事件就绪状态。

而epoll是Linux提供的一种高效的事件通知机制，它可以用于管理大量的文件描述符，并通过**异步方式**通知应用程序有关事件的发生。epoll提供了对ET和LT两种触发模式的支持，可以根据应用程序的需要选择适合的模式。

在epoll中，默认情况下，使用水平触发（LT）模式。这意味着如果应用程序没有读取或写入足够的数据，操作系统会重复通知事件就绪状态。如果需要使用边缘触发（ET）模式，则需要在epoll调用中**通过设置相应的标志来指定。**

注意:

ET模式指的是**边缘触发模式**，表示只有描述符状态发生改变的时候才会触发一次事件，对于读事件来说指的是只有新数据到来时触发一次，后续不管这次数据是否处理都不会触发第二次事件，直到有下次新数据到来。

因为边缘触发是只有新数据到来才会触发一次事件，因此**使用ET模式的时候最好使用循环读取**，将自己需要处理的数据全部处理，避免因为没有新数据到来而导致不触发新事件，使剩下的数据因为无法触发事件而得不到处理

ET边缘触发，有新数据到来的时候才会触发事件，放入EPOLL等待队列

LT模式下，如果还有未处理的数据，事件会再次被触发，并放入EPOLL等待队列。

LT水平触发，对于读是接收缓冲区中有数据可读，也就是有数据就加入等待队列， 对于写是发送缓冲区有剩余空间.

##### poll VS select

优点：

​	不同与select使用三个位图来表示三个fdset的方式，poll使用一个**pollfd的**指针实现. 

​	- pollfd结构包含了要监视的event和发生的revent，不再使用select“参数-值”传递的方式. 接口使用比select更方便.

​	- poll并没有最大数量限制 (但是数量过大后性能也是会下降).

缺点：

​	- 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符.

​	- 每次调用poll都需要把大量的pollfd结构从用户态拷贝到内核中.

​	- 同时连接的大量客户端在一时刻可能只有很少的处于就绪状态, 因此随着监视的描述符数量的增长, 其效率也会线性下降. 