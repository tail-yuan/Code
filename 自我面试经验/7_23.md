#### 如何判断两个浮点数是否相同

在C++中，由于浮点数的存储和表示方式的特殊性，直接使用等号（`==`）运算符来判断两个浮点数是否相同是不可靠的，因为浮点数存在精度限制和舍入误差。

相应地，可以使用以下方法来判断两个浮点数是否相同：

1. 使用一个给定的误差范围（epsilon）来比较两个浮点数的差值是否在该范围内。

2. 计算两个浮点数的差值，并与一个较小的阈值进行比较。

以下是两个常用的方法示例：

##### 1. 使用误差范围比较

```cpp
#include <cmath>

bool areEqual(double a, double b, double epsilon = 1e-8) {//1*10^(-8)
    return std::abs(a - b) < epsilon;
}
```

上述代码中，`areEqual`函数用于比较两个浮点数 `a` 和 `b` 是否相等。`epsilon` 参数是用于定义相等的误差范围，默认值为 `1e-8`。函数内部使用 `std::abs` 函数计算两个浮点数的差的绝对值，并将其与 `epsilon` 进行比较。 

##### 2. 使用阈值比较

```cpp
#include <cmath>

bool areEqual(double a, double b, double threshold = 1e-8) {
    double diff = std::abs(a - b);
    return diff < threshold;
}
```

在上述代码中，`areEqual`函数比较两个浮点数 `a` 和 `b` 是否相等。`threshold` 参数是用于定义相等的阈值，默认为 `1e-8`。函数内部计算两个浮点数的差的绝对值，并将其与 `threshold` 进行比较。

这些方法都是基于误差范围的比较，可以根据具体的需求选择合适的方法和误差范围。需要注意的是，选择合适的误差范围或阈值是关键，需要根据具体应用场景和浮点数的精度来确定。

#### iNode

在C++开发面试中，简单介绍Linux操作系统的inode是一项重要的知识。inode是Linux文件系统中的一个概念，它是索引节点（index node）的缩写。每个文件和目录在Linux文件系统中都与一个唯一的inode相关联，**用于存储文件的元数据信息**，例如文件类型、访问权限、拥有者、所属组、文件大小**、数据块的位置等**。

以下是inode的一些关键信息：

1. **唯一性**：每个inode在文件系统中**都有唯一的编号**，可以通过该编号来**唯一地标识一个文件或目录**。
2. **元数据**：inode存储了文件或目录的元数据，包括文件类型、权限模式、拥有者、所属组、时间戳（创建时间、访问时间和修改时间）、文件大小等信息。这些信息用于管理文件系统，并在访问文件时提供必要的信息。
3. **数据块指针**：inode中包含用于**指向文件数据块的指针**,block表中的位置。对于小文件，这些指针直接指向文件数据的存储位置；对于大文件，inode中的指针指向间接块，而间接块再指向实际的数据块，从而支持更大文件的存储。
4. **目录项**：**目录**本身也是特殊类型的文件，其中存储了**文件名和与之对应的inode编号的映射关系**。通过目录项，Linux文件系统可以根据文件名查找并获取对应的inode，进而获取文件的元数据和数据块。
6. **链接计数**：每个inode还包含一个链接计数**，表示有多少个目录项指向该inode**。当删除文件时，只有当链接计数为零时，才**会真正释放inode和文件的数据块**。(硬链接)

在Linux系统中，可以通过命令`ls -i`查看文件的inode编号，或者通过`stat`命令获取更详细的inode信息。

了解inode在Linux文件系统中的作用和结构对于理解文件系统的运行机制以及性能优化非常重要，因此在C++开发面试中，可能会考察候选人对于inode的了解程度。

#### 内存对齐规则

具体的对齐规则可能因编译器、操作系统和硬件平台而异，但一般情况下，C语言的对齐规则如下：

1. 基本对齐单位：通常是数据成员中最大的基本数据类型的大小。例如，在32位系统上，基本对齐单位通常为4字节，而在64位系统上，它通常为8字节。

2. 成员偏移量：每个成员的**起始地址必须是其数据类型大小的整数倍**。如果一个数据成员的大小不是基本对齐单位的整数倍，编译器将在前面的成员之后插入适当的填充字节，以保证下一个成员按规则正确对齐。

让我们看一个例子来说明对齐规则：

```c
#include <stdio.h>

struct ExampleStruct {
    char a;     // 1字节
    int b;      // 4字节 (基本对齐单位)
    double c;   // 8字节 (基本对齐单位)
    short d;    // 2字节
};
```

在上面的例子中，我们定义了一个结构体`ExampleStruct`，其中包含了不同类型的数据成员。

假设在一个32位的系统上，基本对齐单位为4字节。则根据对齐规则，`a`的地址是0字节对齐，`b`的地址是4字节对齐，`c`的地址是8字节对齐，`d`的地址是2字节对齐。

由于`char`类型占1字节，而`int`类型和`double`类型分别占4字节和8字节，因此编译器会在`a`的后面插入3字节的填充字节，使得`b`的地址是4的倍数，同时在`b`和`c`之间插入4字节的填充字节，使得`c`的地址是8的倍数。

这样，`ExampleStruct`的内存布局在32位系统上可能是：
```
a | padding | b         | padding | c                 | d
--|---------|-----------|---------|-------------------|--
1 |   3     | 4 | 5 | 6 |   7     | 8 | 9 | 10 | 11 | 12
```

在64位系统上，基本对齐单位通常为8字节，但对齐规则和填充方式类似。

需要注意的是，不同编译器可能有不同的实现和优化，因此上述的内存布局仅供示例参考。实际应用中，为了保证结构体的正确对齐，应该遵循C语言的对齐规则，并避免依赖于特定编译器的行为。

在C语言中，结构体是一种自定义的数据类型，允许我们将不同类型的数据成员组合在一起。内存对齐是指编译器在为结构体分配内存时，按照一定规则将结构体成员排列在内存中的过程。这样做的目的是为了优化内存访问效率，避免出现内存碎片，以及确保结构体成员的访问速度最大化。

内存对齐的步骤和注意事项如下：

1. 对齐规则：
   - 基本对齐单位：编译器在决定如何对齐数据成员时，会参考一个基本对齐单位，通常是数据成员中最大的基本数据类型的大小（比如int或double）。
   - 成员偏移量：每个成员的起始地址必须是其数据类型大小的整数倍。
   - 结构体整体对齐：结构体的起始地址必须是结构体中包含的所有数据成员大小的整数倍。

2. 数据成员排列：
   - 编译器会按照结构体中成员的定义顺序，依次将成员排列在内存中。
   - 某些编译器可能会根据优化选项或平台特性对成员排序进行调整，所以不应该依赖于成员的排列顺序。

3. 添加填充：
   - 如果结构体成员的大小不是基本对齐单位的整数倍，编译器会在成员之后添加填充字节，以满足对齐要求。
   - 填充的大小取决于当前成员的大小和基本对齐单位，以确保下一个成员能够按照规则正确对齐。

注意事项：

1. 内存对齐可能会导致结构体的大小增加，但这样做是为了优化内存访问速度。
2. 不同编译器可能对结构体的内存对齐方式有所不同，特别是涉及填充的情况。
3. 使用`#pragma pack`指令或特定编译选项，可以控制编译器的内存对齐行为，但这样做可能会影响代码的可移植性，不推荐随意使用。
4. 在需要与其他系统或硬件进行数据交互时，需要特别注意结构体的内存对齐问题，以免出现不匹配或未定义行为。

总之，理解结构体内存对齐规则并遵循编译器的默认行为是编写稳健、高效代码的重要基础。

#### ET LT区别

A错误：LT水平触发，对于读是接收缓冲区中有数据可读，也就是有数据就加入等待队列， 对于写是发送缓冲区有剩余空间

B错误：ET边缘触发，有新数据到来的时候才会触发事件，放入EPOLL等待队列

C错误；ET边缘触发，对于写来说是状态从不可写变为可写时才会触发事件，放入等待队列