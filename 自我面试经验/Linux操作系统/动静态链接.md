### 动静态链接的区别

首先需要知道源文件编译为可执行程序的四个过程

1. 预处理: `gcc -E -> .i`文件,这个阶段的事情包括,头文件展开,条件编译,去注释,宏替换
2. 编译: `gcc - s->.s`文件,进行语法分析词法分析语义分析,生成汇编代码
3. 汇编: `gcc -c ->.o`文件,将汇编代码生成二进制机器码
4. 链接: 将多个.o文件合并,并链接地址,和各种库,链接为一个可执行文件

![image-20230925155730951](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230925155730951.png)

![image-20230925155750837](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230925155750837.png)

请说一下，静态链接和动态链接的区别是什么？

* 在链接阶段，根据链接过程中处理方式的不同，链接可以分为静态链接和动态链接。

#### 静态链接

是在链接阶段，就把所有需要的函数的二进制代码都包含到可执行文件中去，完成所有符号引用的一种链接方式。`ar`.

静态库会在链接阶段将静态库中的代码复制到可执行文件中，当程序在执行的时候，在可执行文件中本身就有了静态库的代码，可以直接调用。

静态库被打包到可执行程序中，生成的可执行文件较大，但是**程序加载运行速度会比较快**，发布程序时，也无需提供静态库，移植比较方便。

但是当多个程序链接同一个静态库时，生成的每一个可执行文件中，都会含有这个静态库，相当于在内存中同时运行**着两个相同的静态库，比较浪费系统资源**。

另外，当**静态库的内容**发生更新时，依赖该静态库的程序也需要重新进行链接，导致程序的**更新升级会比较麻烦**。

![image-20230925160046895](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230925160046895.png)

#### 动态链接

在链接的时候不直接拷贝相应依赖库的代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，由**操作系统负责将需要的依赖库加载到内存**中，然后程序在运行到指定代码时，去执行内存中已经加载的依赖库的代码，最终达到运行时链接的目的。

![image-20230925160117046](https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230925160117046.png)

* 静态链接和动态链接对应的链接库也不同，可分为两种，**分别是静态链接库和动态链接库**

  在Linux中，静态链接库文件以.a作为文件后缀，动态链接库以.so作为文件后缀。

动态库则不会将代码打包到可执行文件中，而是打包动态库的名称等信息，在可执行程序运行的时候，需要去找到动态库的文件，然后把动态库加载到内存中才可以使用动态库中的代码。

但是存在缺点,因为即使是只是用了一个库中的几个函数也需要将整个库加载到内存当中,然后通过页表映射到程序地址空间当中,可能导致程序占的内存较大.

但是因为是在内存中,当有多个进程同时使用这个动态库时,就可以实现库的共享.也就是说有一分共享库就足够了.

动态库可以实现进程间资源共享，比如可执行程序A在运行时用到了某个动态库，那么系统会将该动态库的代码动态加载到内存中，此时若正在运行的程序B也需要用到该动态库中的代码，则不需要再次加载该动态库，而是可以与程序A共享。

此外，当动态库的内容更新时，只需重新编译生成新的动态库即可，而不需要对依赖该动态库的程序重新进行编译链接。